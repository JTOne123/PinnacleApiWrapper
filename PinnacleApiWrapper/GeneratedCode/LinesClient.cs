//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.4.0 (NJsonSchema v10.0.21.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace Ps3838.Lines
{
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.0.4.0 (NJsonSchema v10.0.21.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial interface ILinesClient
    {
        /// <summary>Get Fixtures - v1</summary>
        /// <param name="sportId">The sport id to retrieve the fixutres for.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="isLive">To retrieve ONLY live events set the value to 1 (isLive=1). Missing or any other value will result in retrieval of events regardless of their Live status.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous fixtures response. When since parameter is not provided, the fixtures are delayed up to 1 minute to encourage the use of the parameter.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<FixturesResponseV1> V1FixturesAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, bool? isLive, long? since);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Fixtures - v1</summary>
        /// <param name="sportId">The sport id to retrieve the fixutres for.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="isLive">To retrieve ONLY live events set the value to 1 (isLive=1). Missing or any other value will result in retrieval of events regardless of their Live status.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous fixtures response. When since parameter is not provided, the fixtures are delayed up to 1 minute to encourage the use of the parameter.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<FixturesResponseV1> V1FixturesAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, bool? isLive, long? since, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Fixtures - v3</summary>
        /// <param name="sportId">The sport id to retrieve the fixutres for.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="isLive">To retrieve ONLY live events set the value to 1 (isLive=1). Missing or any other value will result in retrieval of events regardless of their Live status.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous fixtures response. When since parameter is not provided, the fixtures are delayed up to 1 minute to encourage the use of the parameter.</param>
        /// <param name="eventIds">Comma separated list of event ids to filter by</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FixturesResponseV3> V3FixturesAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, bool? isLive, long? since, System.Collections.Generic.IEnumerable<int> eventIds);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Fixtures - v3</summary>
        /// <param name="sportId">The sport id to retrieve the fixutres for.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="isLive">To retrieve ONLY live events set the value to 1 (isLive=1). Missing or any other value will result in retrieval of events regardless of their Live status.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous fixtures response. When since parameter is not provided, the fixtures are delayed up to 1 minute to encourage the use of the parameter.</param>
        /// <param name="eventIds">Comma separated list of event ids to filter by</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<FixturesResponseV3> V3FixturesAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, bool? isLive, long? since, System.Collections.Generic.IEnumerable<int> eventIds, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Special Fixtures - v1</summary>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last field from the previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="category">The category the special falls under.</param>
        /// <param name="eventId">Id of an event associated with a special.</param>
        /// <param name="specialId">Id of the special.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SpecialsFixturesResponse> V1FixturesSpecialAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, string category, long? eventId, long? specialId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Fixtures - v1</summary>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last field from the previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="category">The category the special falls under.</param>
        /// <param name="eventId">Id of an event associated with a special.</param>
        /// <param name="specialId">Id of the special.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SpecialsFixturesResponse> V1FixturesSpecialAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, string category, long? eventId, long? specialId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Special Fixtures - v2</summary>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last field from the previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="category">The category the special falls under.</param>
        /// <param name="eventId">Id of an event associated with a special.</param>
        /// <param name="specialId">Id of the special.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SpecialsFixturesResponseV2> V2FixturesSpecialAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, string category, long? eventId, long? specialId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Fixtures - v2</summary>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last field from the previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="category">The category the special falls under.</param>
        /// <param name="eventId">Id of an event associated with a special.</param>
        /// <param name="specialId">Id of the special.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SpecialsFixturesResponseV2> V2FixturesSpecialAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, string category, long? eventId, long? specialId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Settled Fixtures - v1</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SettledFixturesSportV1> V1FixturesSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Settled Fixtures - v1</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SettledFixturesSportV1> V1FixturesSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Settled Fixtures - v3</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SettledFixturesSportV3> V3FixturesSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Settled Fixtures - v3</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SettledFixturesSportV3> V3FixturesSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Settled Special Fixtures - v1</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled specials.</param>
        /// <param name="leagueIds">Array of leagueIds. This is optional parameter.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SettledSpecialsResponseV1> V1FixturesSpecialSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Settled Special Fixtures - v1</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled specials.</param>
        /// <param name="leagueIds">Array of leagueIds. This is optional parameter.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SettledSpecialsResponseV1> V1FixturesSpecialSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Settled Special Fixtures - v3</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled specials.</param>
        /// <param name="leagueIds">Array of leagueIds. This is optional parameter.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SettledSpecialsResponseV3> V3FixturesSpecialSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Settled Special Fixtures - v3</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled specials.</param>
        /// <param name="leagueIds">Array of leagueIds. This is optional parameter.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SettledSpecialsResponseV3> V3FixturesSpecialSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Straight Odds - v1</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period did not have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<OddsResponseV1> V1OddsAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat? oddsFormat, long? since, bool? isLive);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Straight Odds - v1</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period did not have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<OddsResponseV1> V1OddsAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat? oddsFormat, long? since, bool? isLive, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Straight Odds - v3</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period did not have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <param name="eventIds">Filter by EventIds</param>
        /// <param name="toCurrencyCode">3 letter currency code as in the [/currency](https://pinnacleapi.github.io/linesapi#operation/Currencies_V2_Get) response. Limits will be returned in the requested currency. Default is USD.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OddsResponseV3> V3OddsAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat2? oddsFormat, long? since, bool? isLive, System.Collections.Generic.IEnumerable<long> eventIds, string toCurrencyCode);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Straight Odds - v3</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period did not have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <param name="eventIds">Filter by EventIds</param>
        /// <param name="toCurrencyCode">3 letter currency code as in the [/currency](https://pinnacleapi.github.io/linesapi#operation/Currencies_V2_Get) response. Limits will be returned in the requested currency. Default is USD.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<OddsResponseV3> V3OddsAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat2? oddsFormat, long? since, bool? isLive, System.Collections.Generic.IEnumerable<long> eventIds, string toCurrencyCode, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Parlay Odds - v1</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period didn’t have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<ParlayOddsResponseV1> V1OddsParlayAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat3? oddsFormat, long? since, bool? isLive);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Parlay Odds - v1</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period didn’t have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<ParlayOddsResponseV1> V1OddsParlayAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat3? oddsFormat, long? since, bool? isLive, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Parlay Odds - v3</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period didn’t have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <param name="eventIds">Filter by EventIds</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ParlayOddsResponseV3> V3OddsParlayAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat4? oddsFormat, long? since, bool? isLive, System.Collections.Generic.IEnumerable<long> eventIds);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Parlay Odds - v3</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period didn’t have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <param name="eventIds">Filter by EventIds</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ParlayOddsResponseV3> V3OddsParlayAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat4? oddsFormat, long? since, bool? isLive, System.Collections.Generic.IEnumerable<long> eventIds, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Teaser Odds - v1</summary>
        /// <param name="teaserId">Unique identifier.Teaser details can be retrieved from a call to Get Teaser Groups endpoint.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TeaserOddsResponse> V1OddsTeaserAsync(long teaserId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Teaser Odds - v1</summary>
        /// <param name="teaserId">Unique identifier.Teaser details can be retrieved from a call to Get Teaser Groups endpoint.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TeaserOddsResponse> V1OddsTeaserAsync(long teaserId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Special Odds - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="specialId">Id of the special. This is an optional argument.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SpecialOddsResponse> V1OddsSpecialAsync(OddsFormat5? oddsFormat, int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, long? specialId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Odds - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="specialId">Id of the special. This is an optional argument.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SpecialOddsResponse> V1OddsSpecialAsync(OddsFormat5? oddsFormat, int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, long? specialId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Special Odds - v2</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="specialId">Id of the special. This is an optional argument.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SpecialOddsResponse> V2OddsSpecialAsync(OddsFormat6? oddsFormat, int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, long? specialId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Odds - v2</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="specialId">Id of the special. This is an optional argument.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SpecialOddsResponse> V2OddsSpecialAsync(OddsFormat6? oddsFormat, int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, long? specialId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Straight Line - v1</summary>
        /// <param name="leagueId">League Id.</param>
        /// <param name="handicap">This is needed for SPREAD, TOTAL_POINTS and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American.</param>
        /// <param name="sportId">Sport identification</param>
        /// <param name="eventId">Event identification</param>
        /// <param name="periodNumber">This represents the period of the match. For example, for soccer we have 0 (Game),  1 (1st Half) &amp; 2 (2nd Half)</param>
        /// <param name="betType">Bet Type</param>
        /// <param name="team">Chosen team type. This is needed only for SPREAD, MONEYLINE and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="side">Chosen side. This is needed only for TOTAL_POINTS and TEAM_TOTAL_POINTS</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<LineResponse> V1LineAsync(int leagueId, double handicap, OddsFormat7 oddsFormat, int sportId, long eventId, int periodNumber, BetType betType, Team? team, Side? side);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Straight Line - v1</summary>
        /// <param name="leagueId">League Id.</param>
        /// <param name="handicap">This is needed for SPREAD, TOTAL_POINTS and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American.</param>
        /// <param name="sportId">Sport identification</param>
        /// <param name="eventId">Event identification</param>
        /// <param name="periodNumber">This represents the period of the match. For example, for soccer we have 0 (Game),  1 (1st Half) &amp; 2 (2nd Half)</param>
        /// <param name="betType">Bet Type</param>
        /// <param name="team">Chosen team type. This is needed only for SPREAD, MONEYLINE and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="side">Chosen side. This is needed only for TOTAL_POINTS and TEAM_TOTAL_POINTS</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<LineResponse> V1LineAsync(int leagueId, double handicap, OddsFormat7 oddsFormat, int sportId, long eventId, int periodNumber, BetType betType, Team? team, Side? side, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Straight Line - v2</summary>
        /// <param name="leagueId">League Id.</param>
        /// <param name="handicap">This is needed for SPREAD, TOTAL_POINTS and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American.</param>
        /// <param name="sportId">Sport identification</param>
        /// <param name="eventId">Event identification</param>
        /// <param name="periodNumber">This represents the period of the match. For example, for soccer we have 0 (Game),  1 (1st Half) &amp; 2 (2nd Half)</param>
        /// <param name="betType">Bet Type</param>
        /// <param name="team">Chosen team type. This is needed only for SPREAD, MONEYLINE and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="side">Chosen side. This is needed only for TOTAL_POINTS and TEAM_TOTAL_POINTS</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LineResponse> V2LineAsync(int leagueId, double handicap, OddsFormat8 oddsFormat, int sportId, long eventId, int periodNumber, BetType2 betType, Team2? team, Side2? side);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Straight Line - v2</summary>
        /// <param name="leagueId">League Id.</param>
        /// <param name="handicap">This is needed for SPREAD, TOTAL_POINTS and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American.</param>
        /// <param name="sportId">Sport identification</param>
        /// <param name="eventId">Event identification</param>
        /// <param name="periodNumber">This represents the period of the match. For example, for soccer we have 0 (Game),  1 (1st Half) &amp; 2 (2nd Half)</param>
        /// <param name="betType">Bet Type</param>
        /// <param name="team">Chosen team type. This is needed only for SPREAD, MONEYLINE and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="side">Chosen side. This is needed only for TOTAL_POINTS and TEAM_TOTAL_POINTS</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LineResponse> V2LineAsync(int leagueId, double handicap, OddsFormat8 oddsFormat, int sportId, long eventId, int periodNumber, BetType2 betType, Team2? team, Side2? side, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Parlay Line - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<ParlayLinesResponse> V1LineParlayAsync(ParlayLinesRequest request);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Parlay Line - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<ParlayLinesResponse> V1LineParlayAsync(ParlayLinesRequest request, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Parlay Line - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ParlayLinesResponse> V2LineParlayAsync(ParlayLinesRequest request);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Parlay Line - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ParlayLinesResponse> V2LineParlayAsync(ParlayLinesRequest request, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Teaser Line - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TeaserLinesResponse> V1LineTeaserAsync(LinesRequestTeaser teaserLinesRequest);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Teaser Line - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TeaserLinesResponse> V1LineTeaserAsync(LinesRequestTeaser teaserLinesRequest, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Special Line - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="specialId">Id of the special.</param>
        /// <param name="contestantId">Id of the contestant.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SpecialLineResponse> V1LineSpecialAsync(OddsFormat9 oddsFormat, long specialId, long contestantId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Line - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="specialId">Id of the special.</param>
        /// <param name="contestantId">Id of the contestant.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SpecialLineResponse> V1LineSpecialAsync(OddsFormat9 oddsFormat, long specialId, long contestantId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Special Line - v2</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="specialId">Id of the special.</param>
        /// <param name="contestantId">Id of the contestant.</param>
        /// <param name="handicap">handicap of the contestant. As contestant's handicap is a mutable property, it may happened that line/special returns status:SUCCESS, but with the different handicap from the one that client had at the moment of calling the line/special. One can specify handicap parameter in the request and if the contestant's handicap changed, it would return status:NOT_EXISTS. This way line/special is more aligned to how /line works.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SpecialLineResponse> V2LineSpecialAsync(OddsFormat10 oddsFormat, long specialId, long contestantId, double? handicap);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Line - v2</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="specialId">Id of the special.</param>
        /// <param name="contestantId">Id of the contestant.</param>
        /// <param name="handicap">handicap of the contestant. As contestant's handicap is a mutable property, it may happened that line/special returns status:SUCCESS, but with the different handicap from the one that client had at the moment of calling the line/special. One can specify handicap parameter in the request and if the contestant's handicap changed, it would return status:NOT_EXISTS. This way line/special is more aligned to how /line works.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SpecialLineResponse> V2LineSpecialAsync(OddsFormat10 oddsFormat, long specialId, long contestantId, double? handicap, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Sports - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SportsResponseV1> V1SportsAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Sports - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<SportsResponseV1> V1SportsAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Sports - v3</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SportsResponseV3> V3SportsAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Sports - v3</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SportsResponseV3> V3SportsAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Leagues - v1</summary>
        /// <param name="sportId">Sport id for which the leagues are requested.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<LeaguesV1> V1LeaguesAsync(string sportId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Leagues - v1</summary>
        /// <param name="sportId">Sport id for which the leagues are requested.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<LeaguesV1> V1LeaguesAsync(string sportId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Leagues - v3</summary>
        /// <param name="sportId">Sport id for which the leagues are requested.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LeaguesV3> V3LeaguesAsync(string sportId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Leagues - v3</summary>
        /// <param name="sportId">Sport id for which the leagues are requested.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LeaguesV3> V3LeaguesAsync(string sportId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Periods - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SportPeriod> V1PeriodsAsync(string sportId);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Periods - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SportPeriod> V1PeriodsAsync(string sportId, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get In-Running - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<InRunningResponse> V1InrunningAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get In-Running - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        System.Threading.Tasks.Task<InRunningResponse> V1InrunningAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get In-Running - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InRunningResponse> V2InrunningAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get In-Running - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InRunningResponse> V2InrunningAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Teaser Groups - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TeaserGroupsResponse> V1TeaserGroupsAsync(OddsFormat11 oddsFormat);
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Teaser Groups - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<TeaserGroupsResponse> V1TeaserGroupsAsync(OddsFormat11 oddsFormat, System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Cancellation Reasons - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CancellationReasonResponse> V1CancellationreasonsAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Cancellation Reasons - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CancellationReasonResponse> V1CancellationreasonsAsync(System.Threading.CancellationToken cancellationToken);
    
        /// <summary>Get Currencies - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SuccessfulCurrenciesResponse> V2CurrenciesAsync();
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Currencies - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SuccessfulCurrenciesResponse> V2CurrenciesAsync(System.Threading.CancellationToken cancellationToken);
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.0.4.0 (NJsonSchema v10.0.21.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class LinesClient : ILinesClient
    {
        private string _baseUrl = "https://api.ps3838.com";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public LinesClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() => 
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>Get Fixtures - v1</summary>
        /// <param name="sportId">The sport id to retrieve the fixutres for.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="isLive">To retrieve ONLY live events set the value to 1 (isLive=1). Missing or any other value will result in retrieval of events regardless of their Live status.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous fixtures response. When since parameter is not provided, the fixtures are delayed up to 1 minute to encourage the use of the parameter.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<FixturesResponseV1> V1FixturesAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, bool? isLive, long? since)
        {
            return V1FixturesAsync(sportId, leagueIds, isLive, since, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Fixtures - v1</summary>
        /// <param name="sportId">The sport id to retrieve the fixutres for.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="isLive">To retrieve ONLY live events set the value to 1 (isLive=1). Missing or any other value will result in retrieval of events regardless of their Live status.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous fixtures response. When since parameter is not provided, the fixtures are delayed up to 1 minute to encourage the use of the parameter.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<FixturesResponseV1> V1FixturesAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, bool? isLive, long? since, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/fixtures?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (isLive != null) 
            {
                urlBuilder_.Append("isLive=").Append(System.Uri.EscapeDataString(ConvertToString(isLive, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FixturesResponseV1>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(FixturesResponseV1);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Fixtures - v3</summary>
        /// <param name="sportId">The sport id to retrieve the fixutres for.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="isLive">To retrieve ONLY live events set the value to 1 (isLive=1). Missing or any other value will result in retrieval of events regardless of their Live status.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous fixtures response. When since parameter is not provided, the fixtures are delayed up to 1 minute to encourage the use of the parameter.</param>
        /// <param name="eventIds">Comma separated list of event ids to filter by</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<FixturesResponseV3> V3FixturesAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, bool? isLive, long? since, System.Collections.Generic.IEnumerable<int> eventIds)
        {
            return V3FixturesAsync(sportId, leagueIds, isLive, since, eventIds, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Fixtures - v3</summary>
        /// <param name="sportId">The sport id to retrieve the fixutres for.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="isLive">To retrieve ONLY live events set the value to 1 (isLive=1). Missing or any other value will result in retrieval of events regardless of their Live status.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous fixtures response. When since parameter is not provided, the fixtures are delayed up to 1 minute to encourage the use of the parameter.</param>
        /// <param name="eventIds">Comma separated list of event ids to filter by</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<FixturesResponseV3> V3FixturesAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, bool? isLive, long? since, System.Collections.Generic.IEnumerable<int> eventIds, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v3/fixtures?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (isLive != null) 
            {
                urlBuilder_.Append("isLive=").Append(System.Uri.EscapeDataString(ConvertToString(isLive, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (eventIds != null) 
            {
                foreach (var item_ in eventIds) { urlBuilder_.Append("eventIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FixturesResponseV3>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(FixturesResponseV3);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Special Fixtures - v1</summary>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last field from the previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="category">The category the special falls under.</param>
        /// <param name="eventId">Id of an event associated with a special.</param>
        /// <param name="specialId">Id of the special.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<SpecialsFixturesResponse> V1FixturesSpecialAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, string category, long? eventId, long? specialId)
        {
            return V1FixturesSpecialAsync(sportId, leagueIds, since, category, eventId, specialId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Fixtures - v1</summary>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last field from the previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="category">The category the special falls under.</param>
        /// <param name="eventId">Id of an event associated with a special.</param>
        /// <param name="specialId">Id of the special.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<SpecialsFixturesResponse> V1FixturesSpecialAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, string category, long? eventId, long? specialId, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/fixtures/special?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (category != null) 
            {
                urlBuilder_.Append("category=").Append(System.Uri.EscapeDataString(ConvertToString(category, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (eventId != null) 
            {
                urlBuilder_.Append("eventId=").Append(System.Uri.EscapeDataString(ConvertToString(eventId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (specialId != null) 
            {
                urlBuilder_.Append("specialId=").Append(System.Uri.EscapeDataString(ConvertToString(specialId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SpecialsFixturesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SpecialsFixturesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Special Fixtures - v2</summary>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last field from the previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="category">The category the special falls under.</param>
        /// <param name="eventId">Id of an event associated with a special.</param>
        /// <param name="specialId">Id of the special.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SpecialsFixturesResponseV2> V2FixturesSpecialAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, string category, long? eventId, long? specialId)
        {
            return V2FixturesSpecialAsync(sportId, leagueIds, since, category, eventId, specialId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Fixtures - v2</summary>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last field from the previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="category">The category the special falls under.</param>
        /// <param name="eventId">Id of an event associated with a special.</param>
        /// <param name="specialId">Id of the special.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SpecialsFixturesResponseV2> V2FixturesSpecialAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, string category, long? eventId, long? specialId, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/fixtures/special?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (category != null) 
            {
                urlBuilder_.Append("category=").Append(System.Uri.EscapeDataString(ConvertToString(category, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (eventId != null) 
            {
                urlBuilder_.Append("eventId=").Append(System.Uri.EscapeDataString(ConvertToString(eventId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (specialId != null) 
            {
                urlBuilder_.Append("specialId=").Append(System.Uri.EscapeDataString(ConvertToString(specialId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SpecialsFixturesResponseV2>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SpecialsFixturesResponseV2);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Settled Fixtures - v1</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<SettledFixturesSportV1> V1FixturesSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since)
        {
            return V1FixturesSettledAsync(sportId, leagueIds, since, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Settled Fixtures - v1</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<SettledFixturesSportV1> V1FixturesSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/fixtures/settled?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SettledFixturesSportV1>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SettledFixturesSportV1);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Settled Fixtures - v3</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SettledFixturesSportV3> V3FixturesSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since)
        {
            return V3FixturesSettledAsync(sportId, leagueIds, since, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Settled Fixtures - v3</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SettledFixturesSportV3> V3FixturesSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v3/fixtures/settled?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SettledFixturesSportV3>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SettledFixturesSportV3);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Settled Special Fixtures - v1</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled specials.</param>
        /// <param name="leagueIds">Array of leagueIds. This is optional parameter.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<SettledSpecialsResponseV1> V1FixturesSpecialSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since)
        {
            return V1FixturesSpecialSettledAsync(sportId, leagueIds, since, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Settled Special Fixtures - v1</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled specials.</param>
        /// <param name="leagueIds">Array of leagueIds. This is optional parameter.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<SettledSpecialsResponseV1> V1FixturesSpecialSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/fixtures/special/settled?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SettledSpecialsResponseV1>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SettledSpecialsResponseV1);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Settled Special Fixtures - v3</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled specials.</param>
        /// <param name="leagueIds">Array of leagueIds. This is optional parameter.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SettledSpecialsResponseV3> V3FixturesSpecialSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since)
        {
            return V3FixturesSpecialSettledAsync(sportId, leagueIds, since, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Settled Special Fixtures - v3</summary>
        /// <param name="sportId">Id of the sport for which to retrieve the settled specials.</param>
        /// <param name="leagueIds">Array of leagueIds. This is optional parameter.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SettledSpecialsResponseV3> V3FixturesSpecialSettledAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v3/fixtures/special/settled?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SettledSpecialsResponseV3>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SettledSpecialsResponseV3);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Straight Odds - v1</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period did not have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<OddsResponseV1> V1OddsAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat? oddsFormat, long? since, bool? isLive)
        {
            return V1OddsAsync(sportId, leagueIds, oddsFormat, since, isLive, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Straight Odds - v1</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period did not have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<OddsResponseV1> V1OddsAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat? oddsFormat, long? since, bool? isLive, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/odds?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (oddsFormat != null) 
            {
                urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isLive != null) 
            {
                urlBuilder_.Append("isLive=").Append(System.Uri.EscapeDataString(ConvertToString(isLive, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OddsResponseV1>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(OddsResponseV1);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Straight Odds - v3</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period did not have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <param name="eventIds">Filter by EventIds</param>
        /// <param name="toCurrencyCode">3 letter currency code as in the [/currency](https://pinnacleapi.github.io/linesapi#operation/Currencies_V2_Get) response. Limits will be returned in the requested currency. Default is USD.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<OddsResponseV3> V3OddsAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat2? oddsFormat, long? since, bool? isLive, System.Collections.Generic.IEnumerable<long> eventIds, string toCurrencyCode)
        {
            return V3OddsAsync(sportId, leagueIds, oddsFormat, since, isLive, eventIds, toCurrencyCode, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Straight Odds - v3</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period did not have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <param name="eventIds">Filter by EventIds</param>
        /// <param name="toCurrencyCode">3 letter currency code as in the [/currency](https://pinnacleapi.github.io/linesapi#operation/Currencies_V2_Get) response. Limits will be returned in the requested currency. Default is USD.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<OddsResponseV3> V3OddsAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat2? oddsFormat, long? since, bool? isLive, System.Collections.Generic.IEnumerable<long> eventIds, string toCurrencyCode, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v3/odds?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (oddsFormat != null) 
            {
                urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isLive != null) 
            {
                urlBuilder_.Append("isLive=").Append(System.Uri.EscapeDataString(ConvertToString(isLive, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (eventIds != null) 
            {
                foreach (var item_ in eventIds) { urlBuilder_.Append("eventIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (toCurrencyCode != null) 
            {
                urlBuilder_.Append("toCurrencyCode=").Append(System.Uri.EscapeDataString(ConvertToString(toCurrencyCode, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<OddsResponseV3>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(OddsResponseV3);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Parlay Odds - v1</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period didn’t have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<ParlayOddsResponseV1> V1OddsParlayAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat3? oddsFormat, long? since, bool? isLive)
        {
            return V1OddsParlayAsync(sportId, leagueIds, oddsFormat, since, isLive, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Parlay Odds - v1</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period didn’t have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<ParlayOddsResponseV1> V1OddsParlayAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat3? oddsFormat, long? since, bool? isLive, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/odds/parlay?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (oddsFormat != null) 
            {
                urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isLive != null) 
            {
                urlBuilder_.Append("isLive=").Append(System.Uri.EscapeDataString(ConvertToString(isLive, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ParlayOddsResponseV1>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ParlayOddsResponseV1);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Parlay Odds - v3</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period didn’t have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <param name="eventIds">Filter by EventIds</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ParlayOddsResponseV3> V3OddsParlayAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat4? oddsFormat, long? since, bool? isLive, System.Collections.Generic.IEnumerable<long> eventIds)
        {
            return V3OddsParlayAsync(sportId, leagueIds, oddsFormat, since, isLive, eventIds, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Parlay Odds - v3</summary>
        /// <param name="sportId">The sportid for which to retrieve the odds.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous odds response. When since parameter is not provided, the odds are delayed up to 1 min to encourage the use of the parameter. Please note that when using since parameter you will get in the response ONLY changed periods. If a period didn’t have any changes it will not be in the response.</param>
        /// <param name="isLive">To retrieve ONLY live odds set the value to 1 (isLive=1). Otherwise response will have all odds.</param>
        /// <param name="eventIds">Filter by EventIds</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ParlayOddsResponseV3> V3OddsParlayAsync(int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, OddsFormat4? oddsFormat, long? since, bool? isLive, System.Collections.Generic.IEnumerable<long> eventIds, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v3/odds/parlay?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (oddsFormat != null) 
            {
                urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (isLive != null) 
            {
                urlBuilder_.Append("isLive=").Append(System.Uri.EscapeDataString(ConvertToString(isLive, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (eventIds != null) 
            {
                foreach (var item_ in eventIds) { urlBuilder_.Append("eventIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ParlayOddsResponseV3>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ParlayOddsResponseV3);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Teaser Odds - v1</summary>
        /// <param name="teaserId">Unique identifier.Teaser details can be retrieved from a call to Get Teaser Groups endpoint.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TeaserOddsResponse> V1OddsTeaserAsync(long teaserId)
        {
            return V1OddsTeaserAsync(teaserId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Teaser Odds - v1</summary>
        /// <param name="teaserId">Unique identifier.Teaser details can be retrieved from a call to Get Teaser Groups endpoint.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TeaserOddsResponse> V1OddsTeaserAsync(long teaserId, System.Threading.CancellationToken cancellationToken)
        {
            if (teaserId == null)
                throw new System.ArgumentNullException("teaserId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/odds/teaser?");
            urlBuilder_.Append("teaserId=").Append(System.Uri.EscapeDataString(ConvertToString(teaserId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TeaserOddsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(TeaserOddsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Special Odds - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="specialId">Id of the special. This is an optional argument.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<SpecialOddsResponse> V1OddsSpecialAsync(OddsFormat5? oddsFormat, int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, long? specialId)
        {
            return V1OddsSpecialAsync(oddsFormat, sportId, leagueIds, since, specialId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Odds - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="specialId">Id of the special. This is an optional argument.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<SpecialOddsResponse> V1OddsSpecialAsync(OddsFormat5? oddsFormat, int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, long? specialId, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/odds/special?");
            if (oddsFormat != null) 
            {
                urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (specialId != null) 
            {
                urlBuilder_.Append("specialId=").Append(System.Uri.EscapeDataString(ConvertToString(specialId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SpecialOddsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SpecialOddsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Special Odds - v2</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="specialId">Id of the special. This is an optional argument.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SpecialOddsResponse> V2OddsSpecialAsync(OddsFormat6? oddsFormat, int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, long? specialId)
        {
            return V2OddsSpecialAsync(oddsFormat, sportId, leagueIds, since, specialId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Odds - v2</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="sportId">Id of a sport for which to retrieve the specials.</param>
        /// <param name="leagueIds">The leagueIds array may contain a list of comma separated league ids.</param>
        /// <param name="since">This is used to receive incremental updates. Use the value of last from previous response. When since parameter is not provided, the fixtures are delayed up to 1 min to encourage the use of the parameter.</param>
        /// <param name="specialId">Id of the special. This is an optional argument.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SpecialOddsResponse> V2OddsSpecialAsync(OddsFormat6? oddsFormat, int sportId, System.Collections.Generic.IEnumerable<int> leagueIds, long? since, long? specialId, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/odds/special?");
            if (oddsFormat != null) 
            {
                urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (leagueIds != null) 
            {
                foreach (var item_ in leagueIds) { urlBuilder_.Append("leagueIds=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            if (since != null) 
            {
                urlBuilder_.Append("since=").Append(System.Uri.EscapeDataString(ConvertToString(since, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (specialId != null) 
            {
                urlBuilder_.Append("specialId=").Append(System.Uri.EscapeDataString(ConvertToString(specialId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SpecialOddsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SpecialOddsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Straight Line - v1</summary>
        /// <param name="leagueId">League Id.</param>
        /// <param name="handicap">This is needed for SPREAD, TOTAL_POINTS and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American.</param>
        /// <param name="sportId">Sport identification</param>
        /// <param name="eventId">Event identification</param>
        /// <param name="periodNumber">This represents the period of the match. For example, for soccer we have 0 (Game),  1 (1st Half) &amp; 2 (2nd Half)</param>
        /// <param name="betType">Bet Type</param>
        /// <param name="team">Chosen team type. This is needed only for SPREAD, MONEYLINE and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="side">Chosen side. This is needed only for TOTAL_POINTS and TEAM_TOTAL_POINTS</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<LineResponse> V1LineAsync(int leagueId, double handicap, OddsFormat7 oddsFormat, int sportId, long eventId, int periodNumber, BetType betType, Team? team, Side? side)
        {
            return V1LineAsync(leagueId, handicap, oddsFormat, sportId, eventId, periodNumber, betType, team, side, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Straight Line - v1</summary>
        /// <param name="leagueId">League Id.</param>
        /// <param name="handicap">This is needed for SPREAD, TOTAL_POINTS and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American.</param>
        /// <param name="sportId">Sport identification</param>
        /// <param name="eventId">Event identification</param>
        /// <param name="periodNumber">This represents the period of the match. For example, for soccer we have 0 (Game),  1 (1st Half) &amp; 2 (2nd Half)</param>
        /// <param name="betType">Bet Type</param>
        /// <param name="team">Chosen team type. This is needed only for SPREAD, MONEYLINE and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="side">Chosen side. This is needed only for TOTAL_POINTS and TEAM_TOTAL_POINTS</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<LineResponse> V1LineAsync(int leagueId, double handicap, OddsFormat7 oddsFormat, int sportId, long eventId, int periodNumber, BetType betType, Team? team, Side? side, System.Threading.CancellationToken cancellationToken)
        {
            if (leagueId == null)
                throw new System.ArgumentNullException("leagueId");
    
            if (handicap == null)
                throw new System.ArgumentNullException("handicap");
    
            if (oddsFormat == null)
                throw new System.ArgumentNullException("oddsFormat");
    
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            if (eventId == null)
                throw new System.ArgumentNullException("eventId");
    
            if (periodNumber == null)
                throw new System.ArgumentNullException("periodNumber");
    
            if (betType == null)
                throw new System.ArgumentNullException("betType");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/line?");
            urlBuilder_.Append("leagueId=").Append(System.Uri.EscapeDataString(ConvertToString(leagueId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("handicap=").Append(System.Uri.EscapeDataString(ConvertToString(handicap, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("eventId=").Append(System.Uri.EscapeDataString(ConvertToString(eventId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("periodNumber=").Append(System.Uri.EscapeDataString(ConvertToString(periodNumber, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("betType=").Append(System.Uri.EscapeDataString(ConvertToString(betType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (team != null) 
            {
                urlBuilder_.Append("team=").Append(System.Uri.EscapeDataString(ConvertToString(team, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (side != null) 
            {
                urlBuilder_.Append("side=").Append(System.Uri.EscapeDataString(ConvertToString(side, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LineResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LineResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Straight Line - v2</summary>
        /// <param name="leagueId">League Id.</param>
        /// <param name="handicap">This is needed for SPREAD, TOTAL_POINTS and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American.</param>
        /// <param name="sportId">Sport identification</param>
        /// <param name="eventId">Event identification</param>
        /// <param name="periodNumber">This represents the period of the match. For example, for soccer we have 0 (Game),  1 (1st Half) &amp; 2 (2nd Half)</param>
        /// <param name="betType">Bet Type</param>
        /// <param name="team">Chosen team type. This is needed only for SPREAD, MONEYLINE and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="side">Chosen side. This is needed only for TOTAL_POINTS and TEAM_TOTAL_POINTS</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LineResponse> V2LineAsync(int leagueId, double handicap, OddsFormat8 oddsFormat, int sportId, long eventId, int periodNumber, BetType2 betType, Team2? team, Side2? side)
        {
            return V2LineAsync(leagueId, handicap, oddsFormat, sportId, eventId, periodNumber, betType, team, side, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Straight Line - v2</summary>
        /// <param name="leagueId">League Id.</param>
        /// <param name="handicap">This is needed for SPREAD, TOTAL_POINTS and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="oddsFormat">Format in which we return the odds. Default is American.</param>
        /// <param name="sportId">Sport identification</param>
        /// <param name="eventId">Event identification</param>
        /// <param name="periodNumber">This represents the period of the match. For example, for soccer we have 0 (Game),  1 (1st Half) &amp; 2 (2nd Half)</param>
        /// <param name="betType">Bet Type</param>
        /// <param name="team">Chosen team type. This is needed only for SPREAD, MONEYLINE and TEAM_TOTAL_POINTS bet types</param>
        /// <param name="side">Chosen side. This is needed only for TOTAL_POINTS and TEAM_TOTAL_POINTS</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LineResponse> V2LineAsync(int leagueId, double handicap, OddsFormat8 oddsFormat, int sportId, long eventId, int periodNumber, BetType2 betType, Team2? team, Side2? side, System.Threading.CancellationToken cancellationToken)
        {
            if (leagueId == null)
                throw new System.ArgumentNullException("leagueId");
    
            if (handicap == null)
                throw new System.ArgumentNullException("handicap");
    
            if (oddsFormat == null)
                throw new System.ArgumentNullException("oddsFormat");
    
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            if (eventId == null)
                throw new System.ArgumentNullException("eventId");
    
            if (periodNumber == null)
                throw new System.ArgumentNullException("periodNumber");
    
            if (betType == null)
                throw new System.ArgumentNullException("betType");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/line?");
            urlBuilder_.Append("leagueId=").Append(System.Uri.EscapeDataString(ConvertToString(leagueId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("handicap=").Append(System.Uri.EscapeDataString(ConvertToString(handicap, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("eventId=").Append(System.Uri.EscapeDataString(ConvertToString(eventId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("periodNumber=").Append(System.Uri.EscapeDataString(ConvertToString(periodNumber, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("betType=").Append(System.Uri.EscapeDataString(ConvertToString(betType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (team != null) 
            {
                urlBuilder_.Append("team=").Append(System.Uri.EscapeDataString(ConvertToString(team, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (side != null) 
            {
                urlBuilder_.Append("side=").Append(System.Uri.EscapeDataString(ConvertToString(side, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LineResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LineResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Parlay Line - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<ParlayLinesResponse> V1LineParlayAsync(ParlayLinesRequest request)
        {
            return V1LineParlayAsync(request, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Parlay Line - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<ParlayLinesResponse> V1LineParlayAsync(ParlayLinesRequest request, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/line/parlay");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ParlayLinesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ParlayLinesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Parlay Line - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<ParlayLinesResponse> V2LineParlayAsync(ParlayLinesRequest request)
        {
            return V2LineParlayAsync(request, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Parlay Line - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<ParlayLinesResponse> V2LineParlayAsync(ParlayLinesRequest request, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/line/parlay");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(request, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ParlayLinesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(ParlayLinesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Teaser Line - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TeaserLinesResponse> V1LineTeaserAsync(LinesRequestTeaser teaserLinesRequest)
        {
            return V1LineTeaserAsync(teaserLinesRequest, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Teaser Line - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TeaserLinesResponse> V1LineTeaserAsync(LinesRequestTeaser teaserLinesRequest, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/line/teaser");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(teaserLinesRequest, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TeaserLinesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(TeaserLinesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Special Line - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="specialId">Id of the special.</param>
        /// <param name="contestantId">Id of the contestant.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<SpecialLineResponse> V1LineSpecialAsync(OddsFormat9 oddsFormat, long specialId, long contestantId)
        {
            return V1LineSpecialAsync(oddsFormat, specialId, contestantId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Line - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="specialId">Id of the special.</param>
        /// <param name="contestantId">Id of the contestant.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<SpecialLineResponse> V1LineSpecialAsync(OddsFormat9 oddsFormat, long specialId, long contestantId, System.Threading.CancellationToken cancellationToken)
        {
            if (oddsFormat == null)
                throw new System.ArgumentNullException("oddsFormat");
    
            if (specialId == null)
                throw new System.ArgumentNullException("specialId");
    
            if (contestantId == null)
                throw new System.ArgumentNullException("contestantId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/line/special?");
            urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("specialId=").Append(System.Uri.EscapeDataString(ConvertToString(specialId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("contestantId=").Append(System.Uri.EscapeDataString(ConvertToString(contestantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SpecialLineResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SpecialLineResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Special Line - v2</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="specialId">Id of the special.</param>
        /// <param name="contestantId">Id of the contestant.</param>
        /// <param name="handicap">handicap of the contestant. As contestant's handicap is a mutable property, it may happened that line/special returns status:SUCCESS, but with the different handicap from the one that client had at the moment of calling the line/special. One can specify handicap parameter in the request and if the contestant's handicap changed, it would return status:NOT_EXISTS. This way line/special is more aligned to how /line works.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SpecialLineResponse> V2LineSpecialAsync(OddsFormat10 oddsFormat, long specialId, long contestantId, double? handicap)
        {
            return V2LineSpecialAsync(oddsFormat, specialId, contestantId, handicap, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Special Line - v2</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <param name="specialId">Id of the special.</param>
        /// <param name="contestantId">Id of the contestant.</param>
        /// <param name="handicap">handicap of the contestant. As contestant's handicap is a mutable property, it may happened that line/special returns status:SUCCESS, but with the different handicap from the one that client had at the moment of calling the line/special. One can specify handicap parameter in the request and if the contestant's handicap changed, it would return status:NOT_EXISTS. This way line/special is more aligned to how /line works.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SpecialLineResponse> V2LineSpecialAsync(OddsFormat10 oddsFormat, long specialId, long contestantId, double? handicap, System.Threading.CancellationToken cancellationToken)
        {
            if (oddsFormat == null)
                throw new System.ArgumentNullException("oddsFormat");
    
            if (specialId == null)
                throw new System.ArgumentNullException("specialId");
    
            if (contestantId == null)
                throw new System.ArgumentNullException("contestantId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/line/special?");
            urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("specialId=").Append(System.Uri.EscapeDataString(ConvertToString(specialId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append("contestantId=").Append(System.Uri.EscapeDataString(ConvertToString(contestantId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            if (handicap != null) 
            {
                urlBuilder_.Append("handicap=").Append(System.Uri.EscapeDataString(ConvertToString(handicap, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SpecialLineResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SpecialLineResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Sports - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<SportsResponseV1> V1SportsAsync()
        {
            return V1SportsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Sports - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<SportsResponseV1> V1SportsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/sports");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SportsResponseV1>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LinesErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<LinesErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SportsResponseV1);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Sports - v3</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SportsResponseV3> V3SportsAsync()
        {
            return V3SportsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Sports - v3</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SportsResponseV3> V3SportsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v3/sports");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SportsResponseV3>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LinesErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<LinesErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SportsResponseV3);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Leagues - v1</summary>
        /// <param name="sportId">Sport id for which the leagues are requested.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<LeaguesV1> V1LeaguesAsync(string sportId)
        {
            return V1LeaguesAsync(sportId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Leagues - v1</summary>
        /// <param name="sportId">Sport id for which the leagues are requested.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<LeaguesV1> V1LeaguesAsync(string sportId, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/leagues?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LeaguesV1>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LeaguesV1);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Leagues - v3</summary>
        /// <param name="sportId">Sport id for which the leagues are requested.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<LeaguesV3> V3LeaguesAsync(string sportId)
        {
            return V3LeaguesAsync(sportId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Leagues - v3</summary>
        /// <param name="sportId">Sport id for which the leagues are requested.</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<LeaguesV3> V3LeaguesAsync(string sportId, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v3/leagues?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LeaguesV3>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(LeaguesV3);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Periods - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SportPeriod> V1PeriodsAsync(string sportId)
        {
            return V1PeriodsAsync(sportId, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Periods - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SportPeriod> V1PeriodsAsync(string sportId, System.Threading.CancellationToken cancellationToken)
        {
            if (sportId == null)
                throw new System.ArgumentNullException("sportId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/periods?");
            urlBuilder_.Append("sportId=").Append(System.Uri.EscapeDataString(ConvertToString(sportId, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SportPeriod>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SportPeriod);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get In-Running - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public System.Threading.Tasks.Task<InRunningResponse> V1InrunningAsync()
        {
            return V1InrunningAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get In-Running - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public async System.Threading.Tasks.Task<InRunningResponse> V1InrunningAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/inrunning");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InRunningResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedLinesErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedLinesErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(InRunningResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get In-Running - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<InRunningResponse> V2InrunningAsync()
        {
            return V2InrunningAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get In-Running - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<InRunningResponse> V2InrunningAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/inrunning");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InRunningResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedLinesErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedLinesErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(InRunningResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Teaser Groups - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<TeaserGroupsResponse> V1TeaserGroupsAsync(OddsFormat11 oddsFormat)
        {
            return V1TeaserGroupsAsync(oddsFormat, System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Teaser Groups - v1</summary>
        /// <param name="oddsFormat">Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</param>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TeaserGroupsResponse> V1TeaserGroupsAsync(OddsFormat11 oddsFormat, System.Threading.CancellationToken cancellationToken)
        {
            if (oddsFormat == null)
                throw new System.ArgumentNullException("oddsFormat");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/teaser/groups?");
            urlBuilder_.Append("oddsFormat=").Append(System.Uri.EscapeDataString(ConvertToString(oddsFormat, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TeaserGroupsResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "400") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("BadRequest", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(TeaserGroupsResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Cancellation Reasons - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<CancellationReasonResponse> V1CancellationreasonsAsync()
        {
            return V1CancellationreasonsAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Cancellation Reasons - v1</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<CancellationReasonResponse> V1CancellationreasonsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v1/cancellationreasons");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CancellationReasonResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(CancellationReasonResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Currencies - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<SuccessfulCurrenciesResponse> V2CurrenciesAsync()
        {
            return V2CurrenciesAsync(System.Threading.CancellationToken.None);
        }
    
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>Get Currencies - v2</summary>
        /// <returns>OK</returns>
        /// <exception cref="LinesApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<SuccessfulCurrenciesResponse> V2CurrenciesAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/v2/currencies");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SuccessfulCurrenciesResponse>(response_, headers_).ConfigureAwait(false);
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == "401") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Unauthorized", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ErrorResponse>("Forbidden", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ExtendedErrorResponse>(response_, headers_).ConfigureAwait(false);
                            throw new LinesApiException<ExtendedErrorResponse>("InternalServerError", (int)response_.StatusCode, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new LinesApiException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(SuccessfulCurrenciesResponse);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }
    
            public T Object { get; }
    
            public string Text { get; }
        }
    
        public bool ReadResponseAsString { get; set; }
        
        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }
        
            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new LinesApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new LinesApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }

    /// <summary>Contains details of an error that was encountered.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ErrorResponse 
    {
        /// <summary>Identifier representing the the type of error that occurred.</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Description of the the error.</summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ExtendedErrorResponse 
    {
        [Newtonsoft.Json.JsonProperty("ref", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ref { get; set; }
    
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LinesErrorResponse 
    {
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorResponse Error { get; set; }
    
        /// <summary>Code identifying an error that occurred.</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Code { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ExtendedLinesErrorResponse 
    {
        [Newtonsoft.Json.JsonProperty("ref", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ref { get; set; }
    
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ErrorResponse Error { get; set; }
    
        /// <summary>Code identifying an error that occurred.</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Code { get; set; }
    
    
    }
    
    /// <summary>Cancellation Response Data</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CancellationReasonResponse 
    {
        /// <summary>Contains a list of Cancellation Reasons.</summary>
        [Newtonsoft.Json.JsonProperty("cancellationReasons", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<CancellationReason> CancellationReasons { get; set; }
    
    
    }
    
    /// <summary>Cancellation Data</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CancellationReason 
    {
        /// <summary>Cancellation code assigned by the server</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Text description for the cancellation reason</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SuccessfulCurrenciesResponse 
    {
        /// <summary>Currencies container.</summary>
        [Newtonsoft.Json.JsonProperty("currencies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Currency> Currencies { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Currency 
    {
        /// <summary>Currency code.</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        /// <summary>Currency name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Exchange rate to USD.</summary>
        [Newtonsoft.Json.JsonProperty("rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Rate { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FixturesResponseV1 
    {
        /// <summary>Same as requested sport Id.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Use this value for the subsequent requests for since query parameter to get just the changes since previous response.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("league", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FixturesLeagueV1> League { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FixturesLeagueV1 
    {
        /// <summary>League ID.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Contains a list of events.</summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FixtureV1> Events { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FixtureV1 
    {
        /// <summary>Event id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Start time of the event in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("starts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Starts { get; set; }
    
        /// <summary>Home team name.</summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Home { get; set; }
    
        /// <summary>Away team name.</summary>
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Away { get; set; }
    
        /// <summary>Team1 rotation number. Please note that in the next version of /fixtures, rotNum property will be decomissioned. ParentId can be used instead to group the related events.</summary>
        [Newtonsoft.Json.JsonProperty("rotNum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RotNum { get; set; }
    
        /// <summary>Indicates live status of the event. 
        /// 
        /// 0 = No live betting will be offered on this event, 
        /// 1 = Live betting event, 
        /// 2 = Live betting will be offered on this event
        /// </summary>
        [Newtonsoft.Json.JsonProperty("liveStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FixtureV1LiveStatus? LiveStatus { get; set; }
    
        /// <summary>Home team pitcher. Only for Baseball.</summary>
        [Newtonsoft.Json.JsonProperty("homePitcher", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HomePitcher { get; set; }
    
        /// <summary>Away team pitcher. Only for Baseball.</summary>
        [Newtonsoft.Json.JsonProperty("awayPitcher", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AwayPitcher { get; set; }
    
        /// <summary>
        /// Status of the event. 
        /// 
        /// O = This is the starting status of a game. It means that the lines are open for betting, 
        /// H = This status indicates that the lines are temporarily unavailable for betting, 
        /// I = This status indicates that one or more lines have a red circle (lower maximum bet amount)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FixtureV1Status? Status { get; set; }
    
        /// <summary>
        /// Parlay status of the event. 
        /// 
        /// 0 = Allowed to parlay, without restrictions, 
        /// 1 = Not allowed to parlay this event, 
        /// 2 = Allowed to parlay with the restrictions. You can not have more than one leg from the same event in the parlay. All events with the same rotation number are treated as same event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parlayRestriction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FixtureV1ParlayRestriction? ParlayRestriction { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FixturesResponseV3 
    {
        /// <summary>Same as requested sport Id.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Use this value for the subsequent requests for since query parameter to get just the changes since previous response.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("league", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FixturesLeagueV3> League { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FixturesLeagueV3 
    {
        /// <summary>League ID.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>League Name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Contains a list of events.</summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FixtureV3> Events { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FixtureV3 
    {
        /// <summary>Event id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>If event is linked to another event , parentId will be populated.  Live event would have pre game event as parent id.</summary>
        [Newtonsoft.Json.JsonProperty("parentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ParentId { get; set; }
    
        /// <summary>Start time of the event in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("starts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Starts { get; set; }
    
        /// <summary>Home team name.</summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Home { get; set; }
    
        /// <summary>Away team name.</summary>
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Away { get; set; }
    
        /// <summary>Team1 rotation number. Please note that in the next version of /fixtures, rotNum property will be decomissioned. ParentId can be used instead to group the related events.</summary>
        [Newtonsoft.Json.JsonProperty("rotNum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RotNum { get; set; }
    
        /// <summary>Indicates live status of the event. 
        /// 
        /// 0 = No live betting will be offered on this event, 
        /// 1 = Live betting event, 
        /// 2 = Live betting will be offered on this event
        /// </summary>
        [Newtonsoft.Json.JsonProperty("liveStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FixtureV3LiveStatus? LiveStatus { get; set; }
    
        /// <summary>Home team pitcher. Only for Baseball.</summary>
        [Newtonsoft.Json.JsonProperty("homePitcher", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HomePitcher { get; set; }
    
        /// <summary>Away team pitcher. Only for Baseball.</summary>
        [Newtonsoft.Json.JsonProperty("awayPitcher", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AwayPitcher { get; set; }
    
        /// <summary>
        /// Status of the event. 
        /// 
        /// O = This is the starting status of a game. It means that the lines are open for betting, 
        /// H = This status indicates that the lines are temporarily unavailable for betting, 
        /// I = This status indicates that one or more lines have a red circle (lower maximum bet amount)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FixtureV3Status? Status { get; set; }
    
        /// <summary>
        /// Parlay status of the event. 
        /// 
        /// 0 = Allowed to parlay, without restrictions, 
        /// 1 = Not allowed to parlay this event, 
        /// 2 = Allowed to parlay with the restrictions. You can not have more than one leg from the same event in the parlay. All events with the same rotation number are treated as same event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parlayRestriction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FixtureV3ParlayRestriction? ParlayRestriction { get; set; }
    
        /// <summary>Whether an event is offer with alterantive teaser points. Events with alternative teaser points may vary from teaser definition.</summary>
        [Newtonsoft.Json.JsonProperty("altTeaser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AltTeaser { get; set; }
    
        /// <summary>Specifies based on what the event will be resulted, e.g. Corners, Bookings
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resultingUnit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResultingUnit { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledFixturesSportV1 
    {
        /// <summary>Same as requested sport Id.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Use this value for the subsequent requests for since query parameter to get just the changes since previous response.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SettledFixturesLeagueV1> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledFixturesLeagueV1 
    {
        /// <summary>League Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Contains a list of events.</summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SettledFixturesEventV1> Events { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledFixturesEventV1 
    {
        /// <summary>Event Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Contains a list of periods.</summary>
        [Newtonsoft.Json.JsonProperty("periods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SettledFixturesPeriodV1> Periods { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledFixturesPeriodV1 
    {
        /// <summary>This represents the period of the match. For example, for soccer we have 0 (Game), 1 (1st Half) &amp; 2 (2nd Half)</summary>
        [Newtonsoft.Json.JsonProperty("number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Number { get; set; }
    
        /// <summary>Period settlement status. 
        /// 
        /// 1 = Event period is settled, 
        /// 2 = Event period is re-settled, 
        /// 3 = Event period is cancelled, 
        /// 4 = Event period is re-settled as cancelled, 
        /// 5 = Event is deleted
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SettledFixturesPeriodV1Status? Status { get; set; }
    
        /// <summary>Unique id of the settlement. In case of a re-settlement, a new settlementId and settledAt will be generated.</summary>
        [Newtonsoft.Json.JsonProperty("settlementId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SettlementId { get; set; }
    
        /// <summary>Date and time in UTC when the period was settled.</summary>
        [Newtonsoft.Json.JsonProperty("settledAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? SettledAt { get; set; }
    
        /// <summary>Team1 score.</summary>
        [Newtonsoft.Json.JsonProperty("team1Score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Team1Score { get; set; }
    
        /// <summary>Team2 score.</summary>
        [Newtonsoft.Json.JsonProperty("team2Score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Team2Score { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledFixturesSportV3 
    {
        /// <summary>Same as requested sport Id.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Use this value for the subsequent requests for since query parameter to get just the changes since previous response.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SettledFixturesLeagueV3> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledFixturesLeagueV3 
    {
        /// <summary>League Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Contains a list of events.</summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SettledFixturesEventV3> Events { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledFixturesEventV3 
    {
        /// <summary>Event Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Contains a list of periods.</summary>
        [Newtonsoft.Json.JsonProperty("periods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SettledFixturesPeriodV3> Periods { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledFixturesPeriodV3 
    {
        /// <summary>This represents the period of the match. For example, for soccer we have 0 (Game), 1 (1st Half) &amp; 2 (2nd Half)</summary>
        [Newtonsoft.Json.JsonProperty("number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Number { get; set; }
    
        /// <summary>Period settlement status. 
        /// 
        /// 1 = Event period is settled, 
        /// 2 = Event period is re-settled, 
        /// 3 = Event period is cancelled, 
        /// 4 = Event period is re-settled as cancelled, 
        /// 5 = Event is deleted
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SettledFixturesPeriodV3Status? Status { get; set; }
    
        /// <summary>Unique id of the settlement. In case of a re-settlement, a new settlementId and settledAt will be generated.</summary>
        [Newtonsoft.Json.JsonProperty("settlementId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SettlementId { get; set; }
    
        /// <summary>Date and time in UTC when the period was settled.</summary>
        [Newtonsoft.Json.JsonProperty("settledAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? SettledAt { get; set; }
    
        /// <summary>Team1 score.</summary>
        [Newtonsoft.Json.JsonProperty("team1Score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Team1Score { get; set; }
    
        /// <summary>Team2 score.</summary>
        [Newtonsoft.Json.JsonProperty("team2Score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Team2Score { get; set; }
    
        [Newtonsoft.Json.JsonProperty("cancellationReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CancellationReasonType CancellationReason { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CancellationReasonType 
    {
        /// <summary>Cancellation Reason Code</summary>
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Code { get; set; }
    
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CancellationReasonDetailsType Details { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CancellationReasonDetailsType 
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }
    
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InRunningResponse 
    {
        /// <summary>Sports container</summary>
        [Newtonsoft.Json.JsonProperty("sports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InRunningSport> Sports { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InRunningSport 
    {
        /// <summary>Sport Id</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Leagues container</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InRunningLeague> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InRunningLeague 
    {
        /// <summary>League Id</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Events container</summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<InRunningEvent> Events { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class InRunningEvent 
    {
        /// <summary>Game Id</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>State of the game.
        /// 
        /// 1 = First half in progress, 
        /// 2 = Half time in progress, 
        /// 3 = Second half in progress, 
        /// 4 = End of regular time,
        /// 5 = First half extra time in progress, 
        /// 6 = Extra time half time in progress, 
        /// 7 = Second half extra time in progress, 
        /// 8 = End of extra time, 
        /// 9 = End of Game, 
        /// 10 = Game is temporary suspended, 
        /// 11 = Penalties in progress
        /// </summary>
        [Newtonsoft.Json.JsonProperty("state", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public InRunningEventState? State { get; set; }
    
        /// <summary>Elapsed minutes</summary>
        [Newtonsoft.Json.JsonProperty("elapsed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Elapsed { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LeaguesV1 
    {
        /// <summary>Leagues container</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LeagueV1> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LeagueV1 
    {
        /// <summary>League Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Name of the league.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Specifies whether the home team is team1 or team2. You need this information to place a bet.</summary>
        [Newtonsoft.Json.JsonProperty("homeTeamType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HomeTeamType { get; set; }
    
        /// <summary>Whether the league currently has events or specials.</summary>
        [Newtonsoft.Json.JsonProperty("hasOfferings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HasOfferings { get; set; }
    
        /// <summary>Specifies whether you can place parlay round robins on events in this league.</summary>
        [Newtonsoft.Json.JsonProperty("allowRoundRobins", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AllowRoundRobins { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LeaguesV3 
    {
        /// <summary>Leagues container</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LeagueV3> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LeagueV3 
    {
        /// <summary>League Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Name of the league.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Specifies whether the home team is team1 or team2. You need this information to place a bet.</summary>
        [Newtonsoft.Json.JsonProperty("homeTeamType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HomeTeamType { get; set; }
    
        /// <summary>Whether the league currently has events or specials.</summary>
        [Newtonsoft.Json.JsonProperty("hasOfferings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HasOfferings { get; set; }
    
        /// <summary>Represents grouping for the league, usually a region/country</summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Container { get; set; }
    
        /// <summary>Specifies whether you can place parlay round robins on events in this league.</summary>
        [Newtonsoft.Json.JsonProperty("allowRoundRobins", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AllowRoundRobins { get; set; }
    
        /// <summary>Indicates how many specials are in the given league.</summary>
        [Newtonsoft.Json.JsonProperty("leagueSpecialsCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? LeagueSpecialsCount { get; set; }
    
        /// <summary>Indicates how many game specials are in the given league.</summary>
        [Newtonsoft.Json.JsonProperty("eventSpecialsCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? EventSpecialsCount { get; set; }
    
        /// <summary>Indicates how many events are in the given league.</summary>
        [Newtonsoft.Json.JsonProperty("eventCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? EventCount { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LineResponse 
    {
        /// <summary>If the value is NOT_EXISTS, than this will be the only parameter in the response. All other params would be empty. [SUCCESS = OK, NOT_EXISTS = Line not offered anymore]</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LineResponseStatus? Status { get; set; }
    
        /// <summary>Latest price.</summary>
        [Newtonsoft.Json.JsonProperty("price", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Price { get; set; }
    
        /// <summary>Line identification needed to place a bet.</summary>
        [Newtonsoft.Json.JsonProperty("lineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LineId { get; set; }
    
        /// <summary>This would be needed to place the bet if the handicap is on alternate line, otherwise it will not be populated in the response.</summary>
        [Newtonsoft.Json.JsonProperty("altLineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AltLineId { get; set; }
    
        /// <summary>Away team score. Applicable to soccer only.</summary>
        [Newtonsoft.Json.JsonProperty("team1Score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Team1Score { get; set; }
    
        /// <summary>Home team score. Applicable to soccer only.</summary>
        [Newtonsoft.Json.JsonProperty("team2Score", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Team2Score { get; set; }
    
        /// <summary>Team 1 red cards. Applicable to soccer only.</summary>
        [Newtonsoft.Json.JsonProperty("team1RedCards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Team1RedCards { get; set; }
    
        /// <summary>Team 2 red cards. Applicable to soccer only.</summary>
        [Newtonsoft.Json.JsonProperty("team2RedCards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Team2RedCards { get; set; }
    
        /// <summary>Maximum bettable risk amount.</summary>
        [Newtonsoft.Json.JsonProperty("maxRiskStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxRiskStake { get; set; }
    
        /// <summary>Minimum bettable risk amount.</summary>
        [Newtonsoft.Json.JsonProperty("minRiskStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MinRiskStake { get; set; }
    
        /// <summary>Maximum bettable win amount.</summary>
        [Newtonsoft.Json.JsonProperty("maxWinStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxWinStake { get; set; }
    
        /// <summary>Minimum bettable win amount.</summary>
        [Newtonsoft.Json.JsonProperty("minWinStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MinWinStake { get; set; }
    
        /// <summary>Line is effective as of this date and time in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("effectiveAsOf", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EffectiveAsOf { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayLinesRequest 
    {
        /// <summary>Odds in the response will be in this format. [American, Decimal, HongKong, Indonesian, Malay]</summary>
        [Newtonsoft.Json.JsonProperty("oddsFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ParlayLinesRequestOddsFormat? OddsFormat { get; set; }
    
        /// <summary>This is a collection of legs</summary>
        [Newtonsoft.Json.JsonProperty("legs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ParlayLineRequest> Legs { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayLineRequest 
    {
        /// <summary>This unique id of the leg. It used to identify and match leg in the response.</summary>
        [Newtonsoft.Json.JsonProperty("uniqueLegId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string UniqueLegId { get; set; }
    
        /// <summary>Id of the event.</summary>
        [Newtonsoft.Json.JsonProperty("eventId", Required = Newtonsoft.Json.Required.Always)]
        public long EventId { get; set; }
    
        /// <summary>This represents the period of the match. For example, for soccer we have 0 (Game), 1 (1st Half), 2 (2nd Half)</summary>
        [Newtonsoft.Json.JsonProperty("periodNumber", Required = Newtonsoft.Json.Required.Always)]
        public int PeriodNumber { get; set; }
    
        /// <summary>Only SPREAD, MONEYLINE and TOTAL_POINTS are supported. [SPREAD, MONEYLINE, TOTAL_POINTS]</summary>
        [Newtonsoft.Json.JsonProperty("legBetType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ParlayLineRequestLegBetType LegBetType { get; set; }
    
        /// <summary>Chosen team type. This is needed only for SPREAD and MONEYLINE wager types. [Team1, Team2, Draw (MONEYLINE only)]</summary>
        [Newtonsoft.Json.JsonProperty("team", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ParlayLineRequestTeam? Team { get; set; }
    
        /// <summary>Chosen side. This is needed only for TOTAL_POINTS wager type.  [OVER, UNDER]</summary>
        [Newtonsoft.Json.JsonProperty("side", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ParlayLineRequestSide? Side { get; set; }
    
        /// <summary>This is needed for SPREAD and TOTAL_POINTS bet type.</summary>
        [Newtonsoft.Json.JsonProperty("handicap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Handicap { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayLinesResponse 
    {
        /// <summary>Status of the parlay [VALID = Parlay is valid, PROCESSED_WITH_ERROR = Parlay contains error(s)]</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ParlayLinesResponseStatus Status { get; set; }
    
        /// <summary>INVALID_LEGS. Signifies that one or more legs are invalid. Populated only if status is PROCESSED_WITH_ERROR.</summary>
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error { get; set; }
    
        /// <summary>Maximum allowed stake amount.</summary>
        [Newtonsoft.Json.JsonProperty("maxRiskStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxRiskStake { get; set; }
    
        /// <summary>Minimum allowed stake amount.</summary>
        [Newtonsoft.Json.JsonProperty("minRiskStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MinRiskStake { get; set; }
    
        /// <summary>Provides array with all acceptable Round Robin options with parlay odds for that option.</summary>
        [Newtonsoft.Json.JsonProperty("roundRobinOptionWithOdds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<RoundRobinOptionWithOdds> RoundRobinOptionWithOdds { get; set; }
    
        /// <summary>The collection of legs (the format of the object is described below).</summary>
        [Newtonsoft.Json.JsonProperty("legs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ParlayLineLeg> Legs { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class RoundRobinOptionWithOdds 
    {
        /// <summary>RoundRobinOptions  
        ///   
        ///   Parlay = Single parlay that include all wagers (No Round Robin),  
        ///   TwoLegRoundRobin = Multiple parlays having 2 wagers each (round robin style),  
        ///   ThreeLegRoundRobin = Multiple parlays having 3 wagers each (round robin style),  
        ///   FourLegRoundRobin = Multiple parlays having 4 wagers each (round robin style),  
        ///   FiveLegRoundRobin = Multiple parlays having 5 wagers each (round robin style),  
        ///   SixLegRoundRobin = Multiple parlays having 6 wagers each (round robin style),  
        ///   SevenLegRoundRobin = Multiple parlays having 7 wagers each (round robin style),   
        ///   EightLegRoundRobin = Multiple parlays having 8 wagers each (round robin style)  
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roundRobinOption", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public RoundRobinOptionWithOddsRoundRobinOption RoundRobinOption { get; set; }
    
        /// <summary>Parlay odds for this option.</summary>
        [Newtonsoft.Json.JsonProperty("odds", Required = Newtonsoft.Json.Required.Always)]
        public double Odds { get; set; }
    
        /// <summary>Unrounded parlay odds in decimal format to be used for calculations only</summary>
        [Newtonsoft.Json.JsonProperty("unroundedDecimalOdds", Required = Newtonsoft.Json.Required.Always)]
        public double UnroundedDecimalOdds { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayLineLeg 
    {
        /// <summary>Status of the request. [VALID = Valid leg, PROCESSED_WITH_ERROR = Processed with error]</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ParlayLineLegStatus Status { get; set; }
    
        /// <summary>When Status is PROCESSED_WITH_ERROR, provides a code indicating the specific problem. 
        /// 
        ///   CORRELATED = The leg is correlated with another one,  
        ///   CANNOT_PARLAY_LIVE_GAME = The wager is placed on Live game,   
        ///   EVENT_NO_LONGER_AVAILABLE_FOR_BETTING = The event is no longer offered for Parlays,  
        ///   EVENT_NOT_OFFERED_FOR_PARLAY = The event is not offered for Parlays,  
        ///   LINE_DOES_NOT_BELONG_TO_EVENT = LineId does not match the EventId specified in the request,  
        ///   WAGER_TYPE_NO_LONGER_AVAILABLE_FOR_BETTING = Wager Type no longer available for betting, 
        ///   WAGER_TYPE_NOT_VALID_FOR_PARLAY =  Wager Type not valid for parlay,  
        ///   WAGER_TYPE_CONFLICTS_WITH_OTHER_LEG = Wager Type conflicts with other leg  
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ParlayLineLegErrorCode? ErrorCode { get; set; }
    
        /// <summary>Echo of the legId from the request.</summary>
        [Newtonsoft.Json.JsonProperty("legId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LegId { get; set; }
    
        /// <summary>Line identification.</summary>
        [Newtonsoft.Json.JsonProperty("lineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LineId { get; set; }
    
        /// <summary>If alternate Line was requested, the Id of that line will be returned.</summary>
        [Newtonsoft.Json.JsonProperty("altLineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AltLineId { get; set; }
    
        /// <summary>Price</summary>
        [Newtonsoft.Json.JsonProperty("price", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Price { get; set; }
    
        /// <summary>If errorCode is CORRELATED will contain legIds of all correlated legs.</summary>
        [Newtonsoft.Json.JsonProperty("correlatedLegs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> CorrelatedLegs { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class LinesRequestTeaser 
    {
        /// <summary>Unique identifier. Teaser details can be retrieved from a call to v1/teaser/groups endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("teaserId", Required = Newtonsoft.Json.Required.Always)]
        public long TeaserId { get; set; }
    
        /// <summary>Format the odds are returned in.. = [American, Decimal, HongKong, Indonesian, Malay]</summary>
        [Newtonsoft.Json.JsonProperty("oddsFormat", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public LinesRequestTeaserOddsFormat OddsFormat { get; set; }
    
        /// <summary>Collection of Teaser Legs.</summary>
        [Newtonsoft.Json.JsonProperty("legs", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TeaserLineRequest> Legs { get; set; } = new System.Collections.ObjectModel.Collection<TeaserLineRequest>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserLineRequest 
    {
        /// <summary>Client genereated GUID for uniquely identifying the leg.</summary>
        [Newtonsoft.Json.JsonProperty("legId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LegId { get; set; }
    
        /// <summary>Unique identifier.</summary>
        [Newtonsoft.Json.JsonProperty("eventId", Required = Newtonsoft.Json.Required.Always)]
        public long EventId { get; set; }
    
        /// <summary>Period of the match that is being bet on. v1/periods endpoint can be used to retrieve all periods for a sport.</summary>
        [Newtonsoft.Json.JsonProperty("periodNumber", Required = Newtonsoft.Json.Required.Always)]
        public int PeriodNumber { get; set; }
    
        /// <summary>Type of bet. Currently only SPREAD and TOTAL_POINTS are supported. [SPREAD, TOTAL_POINTS]</summary>
        [Newtonsoft.Json.JsonProperty("betType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TeaserLineRequestBetType BetType { get; set; }
    
        /// <summary>Team being bet on for a spread line. [Team1, Team2]</summary>
        [Newtonsoft.Json.JsonProperty("team", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TeaserLineRequestTeam? Team { get; set; }
    
        /// <summary>Side of a total line being bet on. [OVER, UNDER]</summary>
        [Newtonsoft.Json.JsonProperty("side", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TeaserLineRequestSide? Side { get; set; }
    
        /// <summary>Number of points.</summary>
        [Newtonsoft.Json.JsonProperty("handicap", Required = Newtonsoft.Json.Required.Always)]
        public double Handicap { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserLinesResponse 
    {
        /// <summary>Status of the request. [VALID = Teaser is valid, PROCESSED_WITH_ERROR = Teaser contains one or more errors]</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TeaserLinesResponseStatus Status { get; set; }
    
        /// <summary>When Status is PROCESSED_WITH_ERROR, provides a code indicating the specific problem.  
        ///    
        ///   INVALID_LEGS = One or more of the legs is invalid,
        ///   SAME_EVENT_ONLY_REQUIRED = Teaser specified requires that all legs are from the same event,  
        ///   TEASER_DISABLED = Teaser has been disabled and cannot be bet on,  
        ///   TEASER_DOES_NOT_EXIST = The teaser identifier could requeted could not be found,  
        ///   TOO_FEW_LEGS = You do not meet the minimum number of legs requirement for the teaser specified,  
        ///   TOO_MANY_LEGS = You are above the maximum number of legs for the teaser specified,  
        ///   UNKNOWN = An unknown error has occured  
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TeaserLinesResponseErrorCode? ErrorCode { get; set; }
    
        /// <summary>Price for the bet.</summary>
        [Newtonsoft.Json.JsonProperty("price", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Price { get; set; }
    
        /// <summary>Minimum bet amount for WIN_RISK_TYPE.RISK.</summary>
        [Newtonsoft.Json.JsonProperty("minRiskStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MinRiskStake { get; set; }
    
        /// <summary>Maximum bet amount for WIN_RISK_TYPE.RISK.</summary>
        [Newtonsoft.Json.JsonProperty("maxRiskStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxRiskStake { get; set; }
    
        /// <summary>Minimum bet amount for WIN_RISK_TYPE.WIN.</summary>
        [Newtonsoft.Json.JsonProperty("minWinStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MinWinStake { get; set; }
    
        /// <summary>Maximum bet amount for WIN_RISK_TYPE.WIN.</summary>
        [Newtonsoft.Json.JsonProperty("maxWinStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxWinStake { get; set; }
    
        /// <summary>Collection of Teaser Legs from the request.</summary>
        [Newtonsoft.Json.JsonProperty("legs", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TeaserLineLeg> Legs { get; set; } = new System.Collections.ObjectModel.Collection<TeaserLineLeg>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserLineLeg 
    {
        /// <summary>Status of the request. [VALID = Teaser is valid, PROCESSED_WITH_ERROR = Teaser contains error(s)]</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TeaserLineLegStatus Status { get; set; }
    
        /// <summary>When Status is PROCESSED_WITH_ERROR, provides a code indicating the specific problem.  
        ///   
        ///   EVENT_NOT_FOUND = The event specified could not be found,  
        ///   POINTS_NO_LONGER_AVAILABLE = The points requested are no longer available. This means that the lines moved,   
        ///   UNKNOWN = An unknown error has occured,  
        ///   WAGER_TYPE_NOT_VALID_FOR_TEASER = The specified wager type is not valid for teasers  
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errorCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TeaserLineLegErrorCode? ErrorCode { get; set; }
    
        /// <summary>Echo of the unique id for the leg from the request.</summary>
        [Newtonsoft.Json.JsonProperty("legId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string LegId { get; set; }
    
        /// <summary>Line identification.</summary>
        [Newtonsoft.Json.JsonProperty("lineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LineId { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsResponseV1 
    {
        /// <summary>Same as requested sport Id.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Use this value for the subsequent requests for since query parameter to get just the changes since previous response.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OddsLeagueV1> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsLeagueV1 
    {
        /// <summary>League Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Contains a list of events.</summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OddsEventV1> Events { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsEventV1 
    {
        /// <summary>Event Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Away team score. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("awayScore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AwayScore { get; set; }
    
        /// <summary>Home team score. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("homeScore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? HomeScore { get; set; }
    
        /// <summary>Away team red cards. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("awayRedCards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? AwayRedCards { get; set; }
    
        /// <summary>Home team red cards. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("homeRedCards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HomeRedCards { get; set; }
    
        /// <summary>Contains a list of periods.</summary>
        [Newtonsoft.Json.JsonProperty("periods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OddsPeriodV1> Periods { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsPeriodV1 
    {
        /// <summary>Line Id.</summary>
        [Newtonsoft.Json.JsonProperty("lineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LineId { get; set; }
    
        /// <summary>This represents the period of the match. For example, for soccer we have  0 (Game), 1 (1st Half) &amp; 2 (2nd Half)</summary>
        [Newtonsoft.Json.JsonProperty("number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Number { get; set; }
    
        /// <summary>Period’s wagering cut-off date in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("cutoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Cutoff { get; set; }
    
        /// <summary>Maximum spread bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxSpread", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxSpread { get; set; }
    
        /// <summary>Maximum moneyline bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxMoneyline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxMoneyline { get; set; }
    
        /// <summary>Maximum total points bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxTotal { get; set; }
    
        /// <summary>Maximum team total points bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxTeamTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxTeamTotal { get; set; }
    
        /// <summary>Container for spread odds.</summary>
        [Newtonsoft.Json.JsonProperty("spreads", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OddsSpreadV1> Spreads { get; set; }
    
        [Newtonsoft.Json.JsonProperty("moneyline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OddsMoneylineV1 Moneyline { get; set; }
    
        /// <summary>Container for team total points.</summary>
        [Newtonsoft.Json.JsonProperty("totals", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OddsTotalV1> Totals { get; set; }
    
        [Newtonsoft.Json.JsonProperty("teamTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OddsTeamTotalsV1 TeamTotal { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsSpreadV1 
    {
        /// <summary>This is present only if it’s alternative line.</summary>
        [Newtonsoft.Json.JsonProperty("altLineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AltLineId { get; set; }
    
        /// <summary>Home team handicap.</summary>
        [Newtonsoft.Json.JsonProperty("hdp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hdp { get; set; }
    
        /// <summary>Home team price.</summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Home { get; set; }
    
        /// <summary>Away team price.</summary>
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Away { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsMoneylineV1 
    {
        /// <summary>Away team price</summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Home { get; set; }
    
        /// <summary>Away team price.</summary>
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Away { get; set; }
    
        /// <summary>Draw price. This is present only for events we offer price for draw.</summary>
        [Newtonsoft.Json.JsonProperty("draw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Draw { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsTotalV1 
    {
        /// <summary>This is present only if it’s alternative line.</summary>
        [Newtonsoft.Json.JsonProperty("altLineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AltLineId { get; set; }
    
        /// <summary>Total points.</summary>
        [Newtonsoft.Json.JsonProperty("points", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Points { get; set; }
    
        /// <summary>Over price.</summary>
        [Newtonsoft.Json.JsonProperty("over", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Over { get; set; }
    
        /// <summary>Under price.</summary>
        [Newtonsoft.Json.JsonProperty("under", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Under { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsTeamTotalsV1 
    {
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OddsTeamTotalV1 Home { get; set; }
    
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OddsTeamTotalV1 Away { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsTeamTotalV1 
    {
        /// <summary>Total points.</summary>
        [Newtonsoft.Json.JsonProperty("points", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Points { get; set; }
    
        /// <summary>Over price.</summary>
        [Newtonsoft.Json.JsonProperty("over", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Over { get; set; }
    
        /// <summary>Under price.</summary>
        [Newtonsoft.Json.JsonProperty("under", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Under { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsResponseV3 
    {
        /// <summary>Same as requested sport Id.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Use this value for the subsequent requests for since query parameter to get just the changes since previous response.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OddsLeagueV3> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsLeagueV3 
    {
        /// <summary>League Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Contains a list of events.</summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OddsEventV3> Events { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsEventV3 
    {
        /// <summary>Event Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Away team score. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("awayScore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AwayScore { get; set; }
    
        /// <summary>Home team score. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("homeScore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? HomeScore { get; set; }
    
        /// <summary>Away team red cards. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("awayRedCards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? AwayRedCards { get; set; }
    
        /// <summary>Home team red cards. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("homeRedCards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HomeRedCards { get; set; }
    
        /// <summary>Contains a list of periods.</summary>
        [Newtonsoft.Json.JsonProperty("periods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OddsPeriodV3> Periods { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsPeriodV3 
    {
        /// <summary>Line Id.</summary>
        [Newtonsoft.Json.JsonProperty("lineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LineId { get; set; }
    
        /// <summary>This represents the period of the match. For example, for soccer we have  0 (Game), 1 (1st Half) &amp; 2 (2nd Half)</summary>
        [Newtonsoft.Json.JsonProperty("number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Number { get; set; }
    
        /// <summary>Period’s wagering cut-off date in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("cutoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Cutoff { get; set; }
    
        /// <summary>1 - online, period is open for betting 
        /// 2 - offline, period is not open for betting
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Status { get; set; }
    
        /// <summary>Maximum spread bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxSpread", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxSpread { get; set; }
    
        /// <summary>Maximum moneyline bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxMoneyline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxMoneyline { get; set; }
    
        /// <summary>Maximum total points bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxTotal { get; set; }
    
        /// <summary>Maximum team total points bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxTeamTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxTeamTotal { get; set; }
    
        /// <summary>Container for spread odds.</summary>
        [Newtonsoft.Json.JsonProperty("spreads", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OddsSpreadV3> Spreads { get; set; }
    
        [Newtonsoft.Json.JsonProperty("moneyline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OddsMoneylineV3 Moneyline { get; set; }
    
        /// <summary>Container for team total points.</summary>
        [Newtonsoft.Json.JsonProperty("totals", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OddsTotalV3> Totals { get; set; }
    
        [Newtonsoft.Json.JsonProperty("teamTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OddsTeamTotalsV3 TeamTotal { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsSpreadV3 
    {
        /// <summary>This is present only if it’s alternative line.</summary>
        [Newtonsoft.Json.JsonProperty("altLineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AltLineId { get; set; }
    
        /// <summary>Home team handicap.</summary>
        [Newtonsoft.Json.JsonProperty("hdp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Hdp { get; set; }
    
        /// <summary>Home team price.</summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Home { get; set; }
    
        /// <summary>Away team price.</summary>
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Away { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsMoneylineV3 
    {
        /// <summary>Away team price</summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Home { get; set; }
    
        /// <summary>Away team price.</summary>
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Away { get; set; }
    
        /// <summary>Draw price. This is present only for events we offer price for draw.</summary>
        [Newtonsoft.Json.JsonProperty("draw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Draw { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsTotalV3 
    {
        /// <summary>This is present only if it’s alternative line.</summary>
        [Newtonsoft.Json.JsonProperty("altLineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AltLineId { get; set; }
    
        /// <summary>Total points.</summary>
        [Newtonsoft.Json.JsonProperty("points", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Points { get; set; }
    
        /// <summary>Over price.</summary>
        [Newtonsoft.Json.JsonProperty("over", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Over { get; set; }
    
        /// <summary>Under price.</summary>
        [Newtonsoft.Json.JsonProperty("under", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Under { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsTeamTotalsV3 
    {
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OddsTeamTotalV3 Home { get; set; }
    
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OddsTeamTotalV3 Away { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OddsTeamTotalV3 
    {
        /// <summary>Total points.</summary>
        [Newtonsoft.Json.JsonProperty("points", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Points { get; set; }
    
        /// <summary>Over price.</summary>
        [Newtonsoft.Json.JsonProperty("over", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Over { get; set; }
    
        /// <summary>Under price.</summary>
        [Newtonsoft.Json.JsonProperty("under", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Under { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsResponseV1 
    {
        /// <summary>Same as requested sport Id.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Always)]
        public int SportId { get; set; }
    
        /// <summary>Use this value for the subsequent requests for since query parameter to get just the changes since previous response.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Always)]
        public long Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ParlayOddsLeagueV1> Leagues { get; set; } = new System.Collections.ObjectModel.Collection<ParlayOddsLeagueV1>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsLeagueV1 
    {
        /// <summary>League Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public int Id { get; set; }
    
        /// <summary>Contains a list of events.</summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ParlayOddsEventV1> Events { get; set; } = new System.Collections.ObjectModel.Collection<ParlayOddsEventV1>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsEventV1 
    {
        /// <summary>Event Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public long Id { get; set; }
    
        /// <summary>Away team score. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("awayScore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AwayScore { get; set; }
    
        /// <summary>Home team score. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("homeScore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? HomeScore { get; set; }
    
        /// <summary>Away team red cards. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("awayRedCards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? AwayRedCards { get; set; }
    
        /// <summary>Home team red cards. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("homeRedCards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HomeRedCards { get; set; }
    
        /// <summary>Contains a list of periods.</summary>
        [Newtonsoft.Json.JsonProperty("periods", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ParlayOddsPeriodV1> Periods { get; set; } = new System.Collections.ObjectModel.Collection<ParlayOddsPeriodV1>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsPeriodV1 
    {
        /// <summary>Line Id.</summary>
        [Newtonsoft.Json.JsonProperty("lineId", Required = Newtonsoft.Json.Required.Always)]
        public long LineId { get; set; }
    
        /// <summary>This represents the period of the match. For example, for soccer we have 0 (Game), 1 (1st Half) &amp; 2 (2nd Half)</summary>
        [Newtonsoft.Json.JsonProperty("number", Required = Newtonsoft.Json.Required.Always)]
        public int Number { get; set; }
    
        /// <summary>Period’s wagering cut-off date in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("cutoff", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Cutoff { get; set; }
    
        /// <summary>Maximum spread bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxSpread", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxSpread { get; set; }
    
        /// <summary>Maximum moneyline bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxMoneyline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxMoneyline { get; set; }
    
        /// <summary>Maximum total points bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxTotal { get; set; }
    
        /// <summary>Maximum team total points bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxTeamTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxTeamTotal { get; set; }
    
        /// <summary>Container for spread odds.</summary>
        [Newtonsoft.Json.JsonProperty("spreads", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ParlayOddsSpreadV1> Spreads { get; set; }
    
        [Newtonsoft.Json.JsonProperty("moneyline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParlayOddsMoneylineV1 Moneyline { get; set; }
    
        /// <summary>Container for team total points.</summary>
        [Newtonsoft.Json.JsonProperty("totals", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ParlayOddsTotalV1> Totals { get; set; }
    
        [Newtonsoft.Json.JsonProperty("teamTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParlayOddsTeamTotalsV1 TeamTotal { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsSpreadV1 
    {
        /// <summary>This is present only if it’s alternative line.</summary>
        [Newtonsoft.Json.JsonProperty("altLineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AltLineId { get; set; }
    
        /// <summary>Home team handicap.</summary>
        [Newtonsoft.Json.JsonProperty("hdp", Required = Newtonsoft.Json.Required.Always)]
        public double Hdp { get; set; }
    
        /// <summary>Home team price.</summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Always)]
        public double Home { get; set; }
    
        /// <summary>Away team price.</summary>
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Always)]
        public double Away { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsMoneylineV1 
    {
        /// <summary>Away team price</summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Always)]
        public double Home { get; set; }
    
        /// <summary>Away team price.</summary>
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Always)]
        public double Away { get; set; }
    
        /// <summary>Draw price. This is present only for events we offer price for draw.</summary>
        [Newtonsoft.Json.JsonProperty("draw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Draw { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsTotalV1 
    {
        /// <summary>Line Id for the alternate line. This is present only if it’s alternative line.</summary>
        [Newtonsoft.Json.JsonProperty("altLineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AltLineId { get; set; }
    
        /// <summary>Total points.</summary>
        [Newtonsoft.Json.JsonProperty("points", Required = Newtonsoft.Json.Required.Always)]
        public double Points { get; set; }
    
        /// <summary>Over price.</summary>
        [Newtonsoft.Json.JsonProperty("over", Required = Newtonsoft.Json.Required.Always)]
        public double Over { get; set; }
    
        /// <summary>Under price.</summary>
        [Newtonsoft.Json.JsonProperty("under", Required = Newtonsoft.Json.Required.Always)]
        public double Under { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsTeamTotalsV1 
    {
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParlayOddsTotalV1 Away { get; set; }
    
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParlayOddsTotalV1 Home { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsResponseV3 
    {
        /// <summary>Same as requested sport Id.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Always)]
        public int SportId { get; set; }
    
        /// <summary>Use this value for the subsequent requests for since query parameter to get just the changes since previous response.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Always)]
        public long Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ParlayOddsLeagueV3> Leagues { get; set; } = new System.Collections.ObjectModel.Collection<ParlayOddsLeagueV3>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsLeagueV3 
    {
        /// <summary>League Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public int Id { get; set; }
    
        /// <summary>Contains a list of events.</summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ParlayOddsEventV3> Events { get; set; } = new System.Collections.ObjectModel.Collection<ParlayOddsEventV3>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsEventV3 
    {
        /// <summary>Event Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        public long Id { get; set; }
    
        /// <summary>Away team score. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("awayScore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AwayScore { get; set; }
    
        /// <summary>Home team score. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("homeScore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? HomeScore { get; set; }
    
        /// <summary>Away team red cards. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("awayRedCards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? AwayRedCards { get; set; }
    
        /// <summary>Home team red cards. Only for live soccer events.</summary>
        [Newtonsoft.Json.JsonProperty("homeRedCards", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HomeRedCards { get; set; }
    
        /// <summary>Contains a list of periods.</summary>
        [Newtonsoft.Json.JsonProperty("periods", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ParlayOddsPeriodV3> Periods { get; set; } = new System.Collections.ObjectModel.Collection<ParlayOddsPeriodV3>();
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsPeriodV3 
    {
        /// <summary>Line Id.</summary>
        [Newtonsoft.Json.JsonProperty("lineId", Required = Newtonsoft.Json.Required.Always)]
        public long LineId { get; set; }
    
        /// <summary>This represents the period of the match. For example, for soccer we have 0 (Game), 1 (1st Half) &amp; 2 (2nd Half)</summary>
        [Newtonsoft.Json.JsonProperty("number", Required = Newtonsoft.Json.Required.Always)]
        public int Number { get; set; }
    
        /// <summary>Period’s wagering cut-off date in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("cutoff", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset Cutoff { get; set; }
    
        /// <summary>1 - online, period is open for betting 
        /// 2 - offline, period is not open for betting
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Status { get; set; }
    
        /// <summary>Maximum spread bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxSpread", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxSpread { get; set; }
    
        /// <summary>Maximum moneyline bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxMoneyline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxMoneyline { get; set; }
    
        /// <summary>Maximum total points bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxTotal { get; set; }
    
        /// <summary>Maximum team total points bet. Only in straight odds response.</summary>
        [Newtonsoft.Json.JsonProperty("maxTeamTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxTeamTotal { get; set; }
    
        /// <summary>Container for spread odds.</summary>
        [Newtonsoft.Json.JsonProperty("spreads", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ParlayOddsSpreadV3> Spreads { get; set; }
    
        [Newtonsoft.Json.JsonProperty("moneyline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParlayOddsMoneylineV3 Moneyline { get; set; }
    
        /// <summary>Container for team total points.</summary>
        [Newtonsoft.Json.JsonProperty("totals", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ParlayOddsTotalV3> Totals { get; set; }
    
        [Newtonsoft.Json.JsonProperty("teamTotal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParlayOddsTeamTotalsV3 TeamTotal { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsSpreadV3 
    {
        /// <summary>This is present only if it’s alternative line.</summary>
        [Newtonsoft.Json.JsonProperty("altLineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? AltLineId { get; set; }
    
        /// <summary>Home team handicap.</summary>
        [Newtonsoft.Json.JsonProperty("hdp", Required = Newtonsoft.Json.Required.Always)]
        public double Hdp { get; set; }
    
        /// <summary>Home team price.</summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Always)]
        public double Home { get; set; }
    
        /// <summary>Away team price.</summary>
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Always)]
        public double Away { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsMoneylineV3 
    {
        /// <summary>Away team price</summary>
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Always)]
        public double Home { get; set; }
    
        /// <summary>Away team price.</summary>
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Always)]
        public double Away { get; set; }
    
        /// <summary>Draw price. This is present only for events we offer price for draw.</summary>
        [Newtonsoft.Json.JsonProperty("draw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Draw { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsTotalV3 
    {
        /// <summary>Line Id for the alternate line. This is present only if it’s alternative line.</summary>
        [Newtonsoft.Json.JsonProperty("altLineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AltLineId { get; set; }
    
        /// <summary>Total points.</summary>
        [Newtonsoft.Json.JsonProperty("points", Required = Newtonsoft.Json.Required.Always)]
        public double Points { get; set; }
    
        /// <summary>Over price.</summary>
        [Newtonsoft.Json.JsonProperty("over", Required = Newtonsoft.Json.Required.Always)]
        public double Over { get; set; }
    
        /// <summary>Under price.</summary>
        [Newtonsoft.Json.JsonProperty("under", Required = Newtonsoft.Json.Required.Always)]
        public double Under { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ParlayOddsTeamTotalsV3 
    {
        [Newtonsoft.Json.JsonProperty("away", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParlayOddsTotalV3 Away { get; set; }
    
        [Newtonsoft.Json.JsonProperty("home", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ParlayOddsTotalV3 Home { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserOddsResponse 
    {
        /// <summary>Unique identifier. Teaser details can be retrieved from a call to Get Teaser Groups endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("teaserId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? TeaserId { get; set; }
    
        /// <summary>Unique identifier. Sport details can be retrieved from a call to Get Sports endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>A collection of League.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TeaserOddsLeague> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserOddsLeague 
    {
        /// <summary>Unique identifier. League details can be retrieved from a call to Get Leagues endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>A collection of Event.</summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TeaserOddsEvent> Events { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserOddsEvent 
    {
        /// <summary>Unique identifier.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>A collection of periods indicating the period numbers available for betting.</summary>
        [Newtonsoft.Json.JsonProperty("periods", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TeaserOddsPeriod> Periods { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserOddsPeriod 
    {
        /// <summary>Period of the match that the request is for. Refer to v1/periods endpoint to retrieve all valid periods for a sport.</summary>
        [Newtonsoft.Json.JsonProperty("number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Number { get; set; }
    
        /// <summary>Unique identifier.</summary>
        [Newtonsoft.Json.JsonProperty("lineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LineId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("spread", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TeaserOddsSpread Spread { get; set; }
    
        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TeaserOddsTotalPoints Total { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserOddsSpread 
    {
        /// <summary>Maximum bet amount.</summary>
        [Newtonsoft.Json.JsonProperty("maxBet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxBet { get; set; }
    
        /// <summary>Home team handicap. Refer to Get Fixtures endpoint to determine home and away teams.</summary>
        [Newtonsoft.Json.JsonProperty("homeHdp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? HomeHdp { get; set; }
    
        /// <summary>Away team handicap. Refer to Get Fixtures endpoint to determine home and away teams.</summary>
        [Newtonsoft.Json.JsonProperty("awayHdp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AwayHdp { get; set; }
    
        /// <summary>Whether the spread is offer with alterantive teaser points. Events with alternative teaser points may vary from teaser definition.</summary>
        [Newtonsoft.Json.JsonProperty("altHdp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AltHdp { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserOddsTotalPoints 
    {
        /// <summary>Maximum bet amount.</summary>
        [Newtonsoft.Json.JsonProperty("maxBet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxBet { get; set; }
    
        /// <summary>Over points.</summary>
        [Newtonsoft.Json.JsonProperty("overPoints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? OverPoints { get; set; }
    
        /// <summary>Under points.</summary>
        [Newtonsoft.Json.JsonProperty("underPoints", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? UnderPoints { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SportPeriod 
    {
        /// <summary>Period Number</summary>
        [Newtonsoft.Json.JsonProperty("number", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Number { get; set; }
    
        /// <summary>Description for the period</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Short description for the period</summary>
        [Newtonsoft.Json.JsonProperty("shortDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ShortDescription { get; set; }
    
        /// <summary>Description for the Spread</summary>
        [Newtonsoft.Json.JsonProperty("spreadDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SpreadDescription { get; set; }
    
        /// <summary>Description for the Moneyline</summary>
        [Newtonsoft.Json.JsonProperty("moneylineDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MoneylineDescription { get; set; }
    
        /// <summary>Description for the Totals</summary>
        [Newtonsoft.Json.JsonProperty("totalDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TotalDescription { get; set; }
    
        /// <summary>Description for Team1 Totals</summary>
        [Newtonsoft.Json.JsonProperty("team1TotalDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Team1TotalDescription { get; set; }
    
        /// <summary>Description for Team2 Totals</summary>
        [Newtonsoft.Json.JsonProperty("team2TotalDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Team2TotalDescription { get; set; }
    
        /// <summary>Short description for the Spread</summary>
        [Newtonsoft.Json.JsonProperty("spreadShortDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SpreadShortDescription { get; set; }
    
        /// <summary>Short description for the Moneyline</summary>
        [Newtonsoft.Json.JsonProperty("moneylineShortDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MoneylineShortDescription { get; set; }
    
        /// <summary>Short description for the Totals</summary>
        [Newtonsoft.Json.JsonProperty("totalShortDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TotalShortDescription { get; set; }
    
        /// <summary>Short description for Team1 Totals</summary>
        [Newtonsoft.Json.JsonProperty("team1TotalShortDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Team1TotalShortDescription { get; set; }
    
        /// <summary>Short description for Team2 Totals</summary>
        [Newtonsoft.Json.JsonProperty("team2TotalShortDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Team2TotalShortDescription { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SportsResponseV1 
    {
        /// <summary>Sports container.</summary>
        [Newtonsoft.Json.JsonProperty("sports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SportV1> Sports { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SportV1 
    {
        /// <summary>Sport Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Sport name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Whether the sport currently has events or specials.</summary>
        [Newtonsoft.Json.JsonProperty("hasOfferings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HasOfferings { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SportsResponseV3 
    {
        /// <summary>Sports container.</summary>
        [Newtonsoft.Json.JsonProperty("sports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SportV3> Sports { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SportV3 
    {
        /// <summary>Sport Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>Sport name.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Whether the sport currently has events or specials.</summary>
        [Newtonsoft.Json.JsonProperty("hasOfferings", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HasOfferings { get; set; }
    
        /// <summary>Indicates how many specials are in the given sport.</summary>
        [Newtonsoft.Json.JsonProperty("leagueSpecialsCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? LeagueSpecialsCount { get; set; }
    
        /// <summary>Indicates how many event specials are in the given sport.</summary>
        [Newtonsoft.Json.JsonProperty("eventSpecialsCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? EventSpecialsCount { get; set; }
    
        /// <summary>Indicates how many events are in the given sport.</summary>
        [Newtonsoft.Json.JsonProperty("eventCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? EventCount { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserGroupsResponse 
    {
        /// <summary>A collection of TeaserGroups containing available teasers.</summary>
        [Newtonsoft.Json.JsonProperty("teaserGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TeaserGroups> TeaserGroups { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserGroups 
    {
        /// <summary>Unique identifier.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Friendly name for the Teaser Group</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>A collection of Teaser.</summary>
        [Newtonsoft.Json.JsonProperty("teasers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TeaserGroupsTeaser> Teasers { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserGroupsTeaser 
    {
        /// <summary>Unique identifier.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Description for the Teaser.</summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }
    
        /// <summary>Unique Sport identifier. Sport details can be retrieved from a call to v2/sports endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Minimum number of legs that must be selected.</summary>
        [Newtonsoft.Json.JsonProperty("minLegs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MinLegs { get; set; }
    
        /// <summary>Maximum number of legs that can be selected.</summary>
        [Newtonsoft.Json.JsonProperty("maxLegs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxLegs { get; set; }
    
        /// <summary>If 'true' then all legs must be from the same event, otherwise legs can be from different events.</summary>
        [Newtonsoft.Json.JsonProperty("sameEventOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SameEventOnly { get; set; }
    
        /// <summary>A collection of Payout indicating all possible payout combinations.</summary>
        [Newtonsoft.Json.JsonProperty("payouts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TeaserGroupsPayout> Payouts { get; set; }
    
        /// <summary>A collection of Leagues available to the teaser.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TeaserGroupsLeague> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserGroupsPayout 
    {
        /// <summary>Number of legs that must be bet and won to get the associated price.</summary>
        [Newtonsoft.Json.JsonProperty("numberOfLegs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NumberOfLegs { get; set; }
    
        /// <summary>Price of the bet given the specified number of legs.</summary>
        [Newtonsoft.Json.JsonProperty("price", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Price { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserGroupsLeague 
    {
        /// <summary>Unique identifier. League details can be retrieved from a call to v2/leagues endpoint.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        [Newtonsoft.Json.JsonProperty("spread", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TeaserGroupsBetType Spread { get; set; }
    
        [Newtonsoft.Json.JsonProperty("total", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TeaserGroupsBetType Total { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TeaserGroupsBetType 
    {
        /// <summary>Number of points the line will be teased for the given league.</summary>
        [Newtonsoft.Json.JsonProperty("points", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Points { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialsFixturesResponse 
    {
        /// <summary>Id of a sport for which to retrieve the odds.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Used for retrieving changes only on subsequent requests. Provide this value as the Since paramter in subsequent calls to only retrieve changes.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SpecialsFixturesLeague> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialsFixturesResponseV2 
    {
        /// <summary>Id of a sport for which to retrieve the odds.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Used for retrieving changes only on subsequent requests. Provide this value as the Since paramter in subsequent calls to only retrieve changes.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SpecialsFixturesLeagueV2> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialsFixturesLeague 
    {
        /// <summary>FixturesLeague Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>A collection of Specials</summary>
        [Newtonsoft.Json.JsonProperty("specials", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SpecialFixture> Specials { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialsFixturesLeagueV2 
    {
        /// <summary>FixturesLeague Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>A collection of Specials</summary>
        [Newtonsoft.Json.JsonProperty("specials", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SpecialFixtureV2> Specials { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialFixture 
    {
        /// <summary>Unique Id</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>The type [MULTI_WAY_HEAD_TO_HEAD, SPREAD, OVER_UNDER]</summary>
        [Newtonsoft.Json.JsonProperty("betType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SpecialFixtureBetType? BetType { get; set; }
    
        /// <summary>Name of the special.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Date of the special in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Date { get; set; }
    
        /// <summary>Wagering cutoff date in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("cutoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Cutoff { get; set; }
    
        /// <summary>The category that the special falls under.</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }
    
        /// <summary>Measurment in the context of the special. This is applicable to specials bet type spead and over/under. In a hockey special this could be goals.</summary>
        [Newtonsoft.Json.JsonProperty("units", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Units { get; set; }
    
        /// <summary>Status of the Special 
        /// 
        /// O = This is the starting status of a game. It means that the lines are open for betting, 
        /// H = This status indicates that the lines are temporarily unavailable for betting, 
        /// I = This status indicates that one or more lines have a red circle (a lower maximum bet amount)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SpecialFixtureStatus? Status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("event", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SpecialsFixturesEvent Event { get; set; }
    
        /// <summary>ContestantLines available for wagering.</summary>
        [Newtonsoft.Json.JsonProperty("contestants", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SpecialsFixturesContestant> Contestants { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialFixtureV2 
    {
        /// <summary>Unique Id</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>The type [MULTI_WAY_HEAD_TO_HEAD, SPREAD, OVER_UNDER]</summary>
        [Newtonsoft.Json.JsonProperty("betType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SpecialFixtureV2BetType? BetType { get; set; }
    
        /// <summary>Name of the special.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Date of the special in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("date", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Date { get; set; }
    
        /// <summary>Wagering cutoff date in UTC.</summary>
        [Newtonsoft.Json.JsonProperty("cutoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Cutoff { get; set; }
    
        /// <summary>The category that the special falls under.</summary>
        [Newtonsoft.Json.JsonProperty("category", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Category { get; set; }
    
        /// <summary>Measurment in the context of the special. This is applicable to specials bet type spead and over/under. In a hockey special this could be goals.</summary>
        [Newtonsoft.Json.JsonProperty("units", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Units { get; set; }
    
        /// <summary>Status of the Special 
        /// 
        /// O = This is the starting status of a game. It means that the lines are open for betting, 
        /// H = This status indicates that the lines are temporarily unavailable for betting, 
        /// I = This status indicates that one or more lines have a red circle (a lower maximum bet amount)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SpecialFixtureV2Status? Status { get; set; }
    
        [Newtonsoft.Json.JsonProperty("event", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SpecialsFixturesEvent Event { get; set; }
    
        /// <summary>ContestantLines available for wagering.</summary>
        [Newtonsoft.Json.JsonProperty("contestants", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SpecialsFixturesContestant> Contestants { get; set; }
    
        /// <summary>When a special is linked to an event, we will return live status of the event, otherwise it will be 0. 0 = No live betting will be offered on this event, 1 = Live betting event, 2 = Live betting will be offered on this match, but on a different event. 
        /// 
        /// Please note that live delay is applied when placing bets on special with LiveStatus=1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("liveStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SpecialFixtureV2LiveStatus? LiveStatus { get; set; }
    
    
    }
    
    /// <summary>Optional event asscoaited with the special.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialsFixturesEvent 
    {
        /// <summary>Event Id</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>The period of the match. For example in soccer 0 (Game), 1 (1st Half) &amp; 2 (2nd Half)</summary>
        [Newtonsoft.Json.JsonProperty("periodNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PeriodNumber { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialsFixturesContestant 
    {
        /// <summary>Contestant Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Name of the contestant.</summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }
    
        /// <summary>Rotation Number.</summary>
        [Newtonsoft.Json.JsonProperty("rotNum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RotNum { get; set; }
    
    
    }
    
    /// <summary>Response dto for SettledSpecials request</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledSpecialsResponseV1 
    {
        /// <summary>Id of a sport for which to retrieve the odds.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Last index for the settled fixture</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>List of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SettledSpecialsLeagueV1> Leagues { get; set; }
    
    
    }
    
    /// <summary>League Dto to hold all settled specials for the league</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledSpecialsLeagueV1 
    {
        /// <summary>League Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>A collection of Settled Specials</summary>
        [Newtonsoft.Json.JsonProperty("specials", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SettledSpecialV1> Specials { get; set; }
    
    
    }
    
    /// <summary>Settled Special</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledSpecialV1 
    {
        /// <summary>Id for the Settled Special</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Status of the settled special.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Status { get; set; }
    
        /// <summary>Id for the Settled Special</summary>
        [Newtonsoft.Json.JsonProperty("settlementId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SettlementId { get; set; }
    
        /// <summary>Settled DateTime</summary>
        [Newtonsoft.Json.JsonProperty("settledAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? SettledAt { get; set; }
    
    
    }
    
    /// <summary>Response dto for SettledSpecials request</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledSpecialsResponseV3 
    {
        /// <summary>Id of a sport for which to retrieve the odds.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Last index for the settled fixture</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>List of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SettledSpecialsLeagueV3> Leagues { get; set; }
    
    
    }
    
    /// <summary>League Dto to hold all settled specials for the league</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledSpecialsLeagueV3 
    {
        /// <summary>League Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>A collection of Settled Specials</summary>
        [Newtonsoft.Json.JsonProperty("specials", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SettledSpecialV3> Specials { get; set; }
    
    
    }
    
    /// <summary>Settled Special</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SettledSpecialV3 
    {
        /// <summary>Id for the Settled Special</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Status of the settled special.</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Status { get; set; }
    
        /// <summary>Id for the Settled Special</summary>
        [Newtonsoft.Json.JsonProperty("settlementId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SettlementId { get; set; }
    
        /// <summary>Settled DateTime</summary>
        [Newtonsoft.Json.JsonProperty("settledAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? SettledAt { get; set; }
    
        /// <summary>Cancellation Reason for Special Event</summary>
        [Newtonsoft.Json.JsonProperty("cancellationReason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CancellationReason CancellationReason { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialLineResponse 
    {
        /// <summary>Status [SUCCESS = OK, NOT_EXISTS = Line not offered anymore]</summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SpecialLineResponseStatus? Status { get; set; }
    
        /// <summary>Special Id.</summary>
        [Newtonsoft.Json.JsonProperty("specialId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? SpecialId { get; set; }
    
        /// <summary>Contestant Id.</summary>
        [Newtonsoft.Json.JsonProperty("contestantId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? ContestantId { get; set; }
    
        /// <summary>Minimum bettable risk amount.</summary>
        [Newtonsoft.Json.JsonProperty("minRiskStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MinRiskStake { get; set; }
    
        /// <summary>Maximum bettable risk amount.</summary>
        [Newtonsoft.Json.JsonProperty("maxRiskStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxRiskStake { get; set; }
    
        /// <summary>Minimum bettable win amount.</summary>
        [Newtonsoft.Json.JsonProperty("minWinStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MinWinStake { get; set; }
    
        /// <summary>Maximum bettable win amount.</summary>
        [Newtonsoft.Json.JsonProperty("maxWinStake", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxWinStake { get; set; }
    
        /// <summary>Line identification needed to place a bet.</summary>
        [Newtonsoft.Json.JsonProperty("lineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LineId { get; set; }
    
        /// <summary>Latest price.</summary>
        [Newtonsoft.Json.JsonProperty("price", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Price { get; set; }
    
        /// <summary>Handicap.</summary>
        [Newtonsoft.Json.JsonProperty("handicap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Handicap { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialOddsResponse 
    {
        /// <summary>Id of a sport for which to retrieve the odds.</summary>
        [Newtonsoft.Json.JsonProperty("sportId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SportId { get; set; }
    
        /// <summary>Used for retrieving changes only on subsequent requests. Provide this value as the Since paramter in subsequent calls to only retrieve changes.</summary>
        [Newtonsoft.Json.JsonProperty("last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Last { get; set; }
    
        /// <summary>Contains a list of Leagues.</summary>
        [Newtonsoft.Json.JsonProperty("leagues", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SpecialOddsLeague> Leagues { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialOddsLeague 
    {
        /// <summary>League id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Id { get; set; }
    
        /// <summary>A collection of FixturesSpecial.</summary>
        [Newtonsoft.Json.JsonProperty("specials", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SpecialOddsSpecial> Specials { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialOddsSpecial 
    {
        /// <summary>Special Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Maximum risk amount.</summary>
        [Newtonsoft.Json.JsonProperty("maxRisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? MaxRisk { get; set; }
    
        /// <summary>ContestantLines available for wagering on.</summary>
        [Newtonsoft.Json.JsonProperty("contestantLines", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SpecialOddsContestantLine> ContestantLines { get; set; }
    
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class SpecialOddsContestantLine 
    {
        /// <summary>ContestantLine Id.</summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? Id { get; set; }
    
        /// <summary>Line identifier required for placing a bet.</summary>
        [Newtonsoft.Json.JsonProperty("lineId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public long? LineId { get; set; }
    
        /// <summary>Price of the line.</summary>
        [Newtonsoft.Json.JsonProperty("price", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Price { get; set; }
    
        /// <summary>A number indicating the spread, over/under etc.</summary>
        [Newtonsoft.Json.JsonProperty("handicap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? Handicap { get; set; }
    
    
    }
    
    /// <summary>Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    /// <summary>Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    /// <summary>Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    /// <summary>Format in which we return the odds. Default is American. [American, Decimal, HongKong, Indonesian, Malay]</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    /// <summary>Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    /// <summary>Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    /// <summary>Format in which we return the odds. Default is American.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    /// <summary>Bet Type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BetType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SPREAD")]
        SPREAD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MONEYLINE")]
        MONEYLINE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOTAL_POINTS")]
        TOTAL_POINTS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TEAM_TOTAL_POINTS")]
        TEAM_TOTAL_POINTS = 3,
    
    }
    
    /// <summary>Chosen team type. This is needed only for SPREAD, MONEYLINE and TEAM_TOTAL_POINTS bet types</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Team
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Team1")]
        Team1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Team2")]
        Team2 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Draw")]
        Draw = 2,
    
    }
    
    /// <summary>Chosen side. This is needed only for TOTAL_POINTS and TEAM_TOTAL_POINTS</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Side
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OVER")]
        OVER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNDER")]
        UNDER = 1,
    
    }
    
    /// <summary>Format in which we return the odds. Default is American.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    /// <summary>Bet Type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BetType2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SPREAD")]
        SPREAD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MONEYLINE")]
        MONEYLINE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOTAL_POINTS")]
        TOTAL_POINTS = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TEAM_TOTAL_POINTS")]
        TEAM_TOTAL_POINTS = 3,
    
    }
    
    /// <summary>Chosen team type. This is needed only for SPREAD, MONEYLINE and TEAM_TOTAL_POINTS bet types</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Team2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Team1")]
        Team1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Team2")]
        Team2 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Draw")]
        Draw = 2,
    
    }
    
    /// <summary>Chosen side. This is needed only for TOTAL_POINTS and TEAM_TOTAL_POINTS</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Side2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OVER")]
        OVER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNDER")]
        UNDER = 1,
    
    }
    
    /// <summary>Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat9
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    /// <summary>Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat10
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    /// <summary>Format the odds are returned in. [American, Decimal, HongKong, Indonesian, Malay]</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OddsFormat11
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FixtureV1LiveStatus
    {
        _0 = 0,
    
        _1 = 1,
    
        _2 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FixtureV1Status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"O")]
        O = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"H")]
        H = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"I")]
        I = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FixtureV1ParlayRestriction
    {
        _0 = 0,
    
        _1 = 1,
    
        _2 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FixtureV3LiveStatus
    {
        _0 = 0,
    
        _1 = 1,
    
        _2 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FixtureV3Status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"O")]
        O = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"H")]
        H = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"I")]
        I = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FixtureV3ParlayRestriction
    {
        _0 = 0,
    
        _1 = 1,
    
        _2 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SettledFixturesPeriodV1Status
    {
        _1 = 1,
    
        _2 = 2,
    
        _3 = 3,
    
        _4 = 4,
    
        _5 = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SettledFixturesPeriodV3Status
    {
        _1 = 1,
    
        _2 = 2,
    
        _3 = 3,
    
        _4 = 4,
    
        _5 = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum InRunningEventState
    {
        _1 = 1,
    
        _2 = 2,
    
        _3 = 3,
    
        _4 = 4,
    
        _5 = 5,
    
        _6 = 6,
    
        _7 = 7,
    
        _8 = 8,
    
        _9 = 9,
    
        _10 = 10,
    
        _11 = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LineResponseStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_EXISTS")]
        NOT_EXISTS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ParlayLinesRequestOddsFormat
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ParlayLineRequestLegBetType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SPREAD")]
        SPREAD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MONEYLINE")]
        MONEYLINE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOTAL_POINTS")]
        TOTAL_POINTS = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ParlayLineRequestTeam
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Team1")]
        Team1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Team2")]
        Team2 = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Draw")]
        Draw = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ParlayLineRequestSide
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OVER")]
        OVER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNDER")]
        UNDER = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ParlayLinesResponseStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VALID")]
        VALID = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROCESSED_WITH_ERROR")]
        PROCESSED_WITH_ERROR = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum RoundRobinOptionWithOddsRoundRobinOption
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Parlay")]
        Parlay = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TwoLegRoundRobin")]
        TwoLegRoundRobin = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ThreeLegRoundRobin")]
        ThreeLegRoundRobin = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FourLegRoundRobin")]
        FourLegRoundRobin = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"FiveLegRoundRobin")]
        FiveLegRoundRobin = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixLegRoundRobin")]
        SixLegRoundRobin = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SevenLegRoundRobin")]
        SevenLegRoundRobin = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EightLegRoundRobin")]
        EightLegRoundRobin = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ParlayLineLegStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VALID")]
        VALID = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROCESSED_WITH_ERROR")]
        PROCESSED_WITH_ERROR = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ParlayLineLegErrorCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"CORRELATED")]
        CORRELATED = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CANNOT_PARLAY_LIVE_GAME")]
        CANNOT_PARLAY_LIVE_GAME = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EVENT_NO_LONGER_AVAILABLE_FOR_BETTING")]
        EVENT_NO_LONGER_AVAILABLE_FOR_BETTING = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EVENT_NOT_OFFERED_FOR_PARLAY")]
        EVENT_NOT_OFFERED_FOR_PARLAY = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LINE_DOES_NOT_BELONG_TO_EVENT")]
        LINE_DOES_NOT_BELONG_TO_EVENT = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAGER_TYPE_NO_LONGER_AVAILABLE_FOR_BETTING")]
        WAGER_TYPE_NO_LONGER_AVAILABLE_FOR_BETTING = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAGER_TYPE_NOT_VALID_FOR_PARLAY")]
        WAGER_TYPE_NOT_VALID_FOR_PARLAY = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAGER_TYPE_CONFLICTS_WITH_OTHER_LEG")]
        WAGER_TYPE_CONFLICTS_WITH_OTHER_LEG = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum LinesRequestTeaserOddsFormat
    {
        [System.Runtime.Serialization.EnumMember(Value = @"American")]
        American = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Decimal")]
        Decimal = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HongKong")]
        HongKong = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Indonesian")]
        Indonesian = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Malay")]
        Malay = 4,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TeaserLineRequestBetType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SPREAD")]
        SPREAD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOTAL_POINTS")]
        TOTAL_POINTS = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TeaserLineRequestTeam
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Team1")]
        Team1 = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Team2")]
        Team2 = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TeaserLineRequestSide
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OVER")]
        OVER = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNDER")]
        UNDER = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TeaserLinesResponseStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VALID")]
        VALID = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROCESSED_WITH_ERROR")]
        PROCESSED_WITH_ERROR = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TeaserLinesResponseErrorCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"INVALID_LEGS")]
        INVALID_LEGS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SAME_EVENT_ONLY_REQUIRED")]
        SAME_EVENT_ONLY_REQUIRED = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TEASER_DISABLED")]
        TEASER_DISABLED = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TEASER_DOES_NOT_EXIST")]
        TEASER_DOES_NOT_EXIST = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOO_FEW_LEGS")]
        TOO_FEW_LEGS = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TOO_MANY_LEGS")]
        TOO_MANY_LEGS = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 6,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TeaserLineLegStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"VALID")]
        VALID = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PROCESSED_WITH_ERROR")]
        PROCESSED_WITH_ERROR = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TeaserLineLegErrorCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"EVENT_NOT_FOUND")]
        EVENT_NOT_FOUND = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POINTS_NO_LONGER_AVAILABLE")]
        POINTS_NO_LONGER_AVAILABLE = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"WAGER_TYPE_NOT_VALID_FOR_TEASER")]
        WAGER_TYPE_NOT_VALID_FOR_TEASER = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SpecialFixtureBetType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MULTI_WAY_HEAD_TO_HEAD")]
        MULTI_WAY_HEAD_TO_HEAD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SPREAD")]
        SPREAD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OVER_UNDER")]
        OVER_UNDER = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SpecialFixtureStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"O")]
        O = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"H")]
        H = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"I")]
        I = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SpecialFixtureV2BetType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"MULTI_WAY_HEAD_TO_HEAD")]
        MULTI_WAY_HEAD_TO_HEAD = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SPREAD")]
        SPREAD = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OVER_UNDER")]
        OVER_UNDER = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SpecialFixtureV2Status
    {
        [System.Runtime.Serialization.EnumMember(Value = @"O")]
        O = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"H")]
        H = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"I")]
        I = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SpecialFixtureV2LiveStatus
    {
        _0 = 0,
    
        _1 = 1,
    
        _2 = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.0.21.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum SpecialLineResponseStatus
    {
        [System.Runtime.Serialization.EnumMember(Value = @"SUCCESS")]
        SUCCESS = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NOT_EXISTS")]
        NOT_EXISTS = 1,
    
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.0.4.0 (NJsonSchema v10.0.21.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class LinesApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public LinesApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.0.4.0 (NJsonSchema v10.0.21.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class LinesApiException<TResult> : LinesApiException
    {
        public TResult Result { get; private set; }

        public LinesApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108